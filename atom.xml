<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>未知的世界</title>
  
  <subtitle>The Unknown World</subtitle>
  <link href="https://philo-li.com/atom.xml" rel="self"/>
  
  <link href="https://philo-li.com/"/>
  <updated>2024-04-17T10:37:41.523Z</updated>
  <id>https://philo-li.com/</id>
  
  <author>
    <name>Philo Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始搭建 Hexo 博客简明教程（2024版）</title>
    <link href="https://philo-li.com/building-a-blog-from-scratch/"/>
    <id>https://philo-li.com/building-a-blog-from-scratch/</id>
    <published>2024-04-10T15:25:20.000Z</published>
    <updated>2024-04-17T10:37:41.523Z</updated>
    
    <content type="html"><![CDATA[<p>你是不是早就厌倦了那些博客网站毫无美感的界面，是不是受够了无休无止的网站推送，是不是早就想建立一个属于自己的博客，却止步于复杂的教程以及一系列令人头疼的代码？那么恭喜你，这篇文章就是想以最浅显易懂的方式手把手教你搭建属于自己的博客，你只需要一点耐心，一步步跟着做。</p><span id="more"></span><p>Hexo 作为一个快速、简洁且高效的博客框架，简直是小白们的福音，而 GitHub 又免去了我们额外租用并部署服务器的麻烦。因此本文将利用 Hexo 及 GitHub 搭建博客。</p><p>曾经我在 2018 年写过一篇 <a href="https://lulalap.com/2018/01/25/building-a-blog-from-scratch/">从零开始搭建博客简明教程</a>,因为插件的更新，有一些细节需要改动，因此重新推出 2024 版的简明教程。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>下载安装 node.js （<a href="https://nodejs.org/en/">官网下载安装</a>）</li><li>下载安装 git （<a href="https://git-scm.com/downloads">官网下载安装</a>）</li></ul><h3 id="本地搭建-hexo-静态博客"><a href="#本地搭建-hexo-静态博客" class="headerlink" title="本地搭建 hexo 静态博客"></a>本地搭建 hexo 静态博客</h3><ul><li>安装 hexo 框架: 打开 cmd 运行</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>新建一个文件夹，如 MyBlog ，进入该文件夹内，右击运行 git ，输入：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><ul><li>生成完 hexo 模板，安装 npm ，运行：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>没错，博客的主体部分到此已经完成了，来看看效果吧。运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>这时候打开浏览器，输入 localhost:4000 就可以看到博客目前的样子了。小小激动一下，然后按 Ctrl + C 就可以继续下面的操作了。</p><h3 id="个性化设置（初步）"><a href="#个性化设置（初步）" class="headerlink" title="个性化设置（初步）"></a>个性化设置（初步）</h3><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ul><li>下载新的主题（以<a href="http://theme-next.iissnan.com/">NexT 主题</a>为例），在根目录下运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><ul><li>打开根目录下的 <code>_config.yml</code>，修改字段 <code>theme</code> 为:</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><ul><li>选择外观：打开 <code>/themes/next/_config.yml</code> ， 找到 <code>scheme</code> 字段（可用 Ctrl + F 快捷查找）。NexT提供了三种不同的外观，可以挑选一个自己喜欢的，然后去掉其中一个的 # 号(后续主要修改的也就是这两个文件： <em>站点配置文件</em> 和 <em>主题配置文件</em> 。)。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><ul><li>查看效果，可运行如下命令(以后每次想查看效果都可重复此步骤)：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#或者 hexo generate</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><ul><li>使用编辑器打开根目录下的站点配置文件 <code>_config.yml</code> （ Windows下不要使用记事本编辑，中文标题会出现乱码），修改字段 <code>Site</code> ， 注意冒号后面要有空格：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 未知的世界                //博客名称</span><br><span class="line">subtitle:</span><br><span class="line">description:  Do something cool //一句签名</span><br><span class="line">author: LulalaP                 //作者</span><br><span class="line">language: zh-Hans               //网站语言</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><h3 id="设置侧边栏头像"><a href="#设置侧边栏头像" class="headerlink" title="设置侧边栏头像"></a>设置侧边栏头像</h3><ul><li><p>在 <code>/source</code> 中新建文件夹并命名为 <code>uploads</code> , 将头像图片（如： avatar.jpg ）放到该文件夹内</p></li><li><p>打开 <code>/themes/next/_config.yml</code> ，找到字段 <code>avatar</code> 并修改为:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avatar: </span><br><span class="line">    url: /uploads/avatar.jpg</span><br></pre></td></tr></table></figure><h3 id="完善博客页面"><a href="#完善博客页面" class="headerlink" title="完善博客页面"></a>完善博客页面</h3><h4 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h4><ul><li>打开 <code>/themes/next/_config.yml</code> ，将字段 <code>menu</code> 中需要添加的菜单前面的注释去掉即可。如需要添加其他菜单可按需添加（注意字段的缩进）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure><h4 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h4><ul><li>新建一个页面，命名为 <code>categories</code> ，命令如下：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><ul><li>编辑刚新建的页面 <code>/source/categories/index.md</code> ，将页面的类型设置为 <code>categories</code> ，主题将自动为这个页面显示所有分类（注意保留冒号后的空格）。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Categories</span><br><span class="line"><span class="built_in">date</span>: 2024-04-10 23:40:31</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><h4 id="创建标签云界面"><a href="#创建标签云界面" class="headerlink" title="创建标签云界面"></a>创建标签云界面</h4><ul><li>新建一个页面，命名为 tags ，命令如下:</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure><ul><li>编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line"><span class="built_in">date</span>: 2024-04-10 23:41:25</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="创建”关于我”页面"><a href="#创建”关于我”页面" class="headerlink" title="创建”关于我”页面"></a>创建”关于我”页面</h4><ul><li>新建一个 about 页面：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure><ul><li>编辑刚新建的页面，可在正文处用 Markdown 格式写下信息。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: About</span><br><span class="line"><span class="built_in">date</span>: 2024-04-10 23:41:56</span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="设置侧边栏社交链接"><a href="#设置侧边栏社交链接" class="headerlink" title="设置侧边栏社交链接"></a>设置侧边栏社交链接</h3><ul><li>编辑站点的 <code>_config.yml</code>，找到字段 <code>social</code> ，然后添加社交站点名称与地址即可。键值格式为 <code>显示名称：链接地址</code> ，例如：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Social links</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/your-user-name || fab fa-github</span><br><span class="line">  E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  Twitter: https://x.com/your-user-name || fab fa-twitter</span><br></pre></td></tr></table></figure><ul><li>打开 <code>/themes/next/_config.yml</code>, 在 <code>social_icons</code> 字段下添加社交站点名称（注意大小写）与(图标)[<a href="http://fontawesome.io/icons/]%E3%80%82">http://fontawesome.io/icons/]。</a> enable 选项用于控制是否显示图标，你可以设置成 <code>false</code> 来去掉图标。例如：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">social_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br></pre></td></tr></table></figure><h3 id="将博客与GitHub关联"><a href="#将博客与GitHub关联" class="headerlink" title="将博客与GitHub关联"></a>将博客与GitHub关联</h3><ul><li><p>注册 GitHub 账号：如果还没有 GitHub 账号的，需要先注册一个</p></li><li><p>在 Github 上创建名字为 <code>XXX.github.io</code> 的项目，XXX为自己的 GitHub 用户名。</p></li><li><p>打开本地的 <code>MyBlog</code> 文件夹项目内的 <code>_config.yml</code> 配置文件，将其中的 <code>type</code> 设置为 <code>git</code> :</p></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/your-name/your-name.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><ul><li>运行：</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>本地生成静态文件，并将静态文件推送至GitHub，运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p> 此时，打开浏览器，访问 <a href="http://your-name.github.io/">http://your-name.github.io</a> ，恭喜你，到此为止你的博客已经建设完毕了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>到目前为止博客已经全部搭建完成，也能通过 GitHub 的域名访问，这时候再用一个短域名绑定到这个博客上就更完美了。</p><h4 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h4><ul><li>购买一个域名，推荐在 <a href="https://www.namesilo.com/">namesilo.com</a> 上购买，老牌的域名提供商，价格优惠服务靠谱。如果你使用我的推荐码 <code>PhiloArt.io</code>，还可以可获得优惠 1 美元，有效期至 2025-12-31。</li></ul><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><ul><li><p>域名提供商 DNS 设置</p></li><li><p>添加 4 条 A 记录，用于指向 GitHub Pages：</p></li></ul><blockquote><p>185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153</p></blockquote><ul><li>添加一条 <code>CNAME</code> 记录，<code>name</code> 为 <code>www</code>，<code>content</code> 为 <code>your-name.github.io</code>（指向你的 Github Pages 地址）：</li></ul><blockquote><p>CNAME —&gt; philo-li.github.io</p></blockquote><ul><li><p>更详细的设置请参见 <a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain">GitHub Pages Docs</a></p></li><li><p>博客目录添加 CNAME 文件</p></li></ul><p> 配置完域名解析后，进入博客目录，在 <code>source</code> 目录下新建一个命名为 <code>CNAME</code> 的文件(注意要大写，没有后缀)，用记事本打开编辑，写入购买好的域名，如：<code>www.philoli.com</code></p><ul><li>运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>现在打开浏览器，输入域名，回车，恭喜你已经拥有了一个属于自己独立域名的博客。</p><h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><ul><li><p>在博客根目录下执行：<code>hexo new “我的第一篇文章”</code>，会在 <code>source/_posts</code> 文件夹内生成一个 <code>.md</code> 文件。</p></li><li><p>编辑该文件，修改起始字段为：</p></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title 文章的标题</span><br><span class="line"><span class="built_in">date</span> 创建日期 （文件的创建日期 ）</span><br><span class="line">updated 修改日期 （ 文件的修改日期）</span><br><span class="line">comments 是否开启评论 <span class="literal">true</span></span><br><span class="line">tags 标签</span><br><span class="line">categories 分类</span><br><span class="line">permalink url中的名字（文件名）</span><br></pre></td></tr></table></figure><ul><li><p>编写正文内容(遵循 Markdown 规则)</p></li><li><p>本地生成静态文件，并将静态文件推送至 GitHub，运行：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="个性化设置（进阶）"><a href="#个性化设置（进阶）" class="headerlink" title="个性化设置（进阶）"></a>个性化设置（进阶）</h3><p>下面提供一些进阶的个性化博客样式设置，新手可先跳过。</p><h4 id="添加-RSS"><a href="#添加-RSS" class="headerlink" title="添加 RSS"></a>添加 RSS</h4><ul><li>在根目录下安装插件</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><ul><li>在根目录的 <code>_config.yml</code> 里面的末尾添加：(<strong><em>请注意在冒号后面要加一个空格，不然会发生错误！</em></strong>)</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><ul><li>打开 <code>/themes/next/_config.yml</code> ,修改 <code>rss</code> (注意在冒号后面要加一个空格)</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure><h4 id="首页文章截断"><a href="#首页文章截断" class="headerlink" title="首页文章截断"></a>首页文章截断</h4><ul><li>每次写文章正文时，只需要在文章 .md 中需要截断的地方增加：</li></ul> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><ul><li>打开 <code>/themes/next/_config.yml</code>，修改 <code>scroll_to_more</code> 这个选项设置为 <code>false</code> 。</li></ul><h4 id="文章内的引用文字居中"><a href="#文章内的引用文字居中" class="headerlink" title="文章内的引用文字居中"></a>文章内的引用文字居中</h4><ul><li>优化了 Markdown 默认的引用的样式</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% centerquote %&#125;</span><br><span class="line">引用正文</span><br><span class="line">&#123;% endcenterquote %&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>引用正文</p>            <i class="fa fa-quote-right"></i>          </blockquote><h4 id="修改代码块样式"><a href="#修改代码块样式" class="headerlink" title="修改代码块样式"></a>修改代码块样式</h4><ul><li>编辑 <code>/themes/next/_config.yml</code> ，修改 <code>codeblock</code> 配置如下</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">eighties</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure><h4 id="设定站点建立时间"><a href="#设定站点建立时间" class="headerlink" title="设定站点建立时间"></a>设定站点建立时间</h4><ul><li>编辑站点的 <code>_config.yml</code> ，新增字段 <code>since</code> 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">since: 2024</span><br></pre></td></tr></table></figure><h4 id="改进文章链接样式"><a href="#改进文章链接样式" class="headerlink" title="改进文章链接样式"></a>改进文章链接样式</h4><ul><li>编辑修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下 css 样式，：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// link style</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="给博客增加背景图"><a href="#给博客增加背景图" class="headerlink" title="给博客增加背景图"></a>给博客增加背景图</h4><ul><li>在根目录的 <code>source</code> 文件夹下创建 <code>_data</code> 文件夹，新建 <code>styles.styl</code> 文件，打开新建的文件 <code>source/_data/styles.styl</code>，添加如下内容</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/uploads/background.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;   //图片无法铺满时，是否重复以及重复方式</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;    //图片是否跟随滚动</span><br><span class="line">    <span class="attribute">background-size</span>: cover;         //覆盖</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;    //图片位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>url 中可以是图片链接，或者是图片目录。可以将图片命名为 <code>background.jpg</code>，并放入 <code>source/uploads</code> 文件夹内。</li></ul><h4 id="博客内容背景设置半透明"><a href="#博客内容背景设置半透明" class="headerlink" title="博客内容背景设置半透明"></a>博客内容背景设置半透明</h4><ul><li>打开上一步编辑的文件 <code>source/_data/styles.styl</code>，继续在下面增加如下内容</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line">if (hexo-config(&#x27;motion<span class="selector-class">.transition</span><span class="selector-class">.post_block</span>&#x27;)) &#123;</span><br><span class="line">  <span class="selector-class">.post-block</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">    radius: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">40px</span>;</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">    -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.pagination</span>, <span class="selector-class">.comments</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化行内代码块的样式"><a href="#优化行内代码块的样式" class="headerlink" title="优化行内代码块的样式"></a>优化行内代码块的样式</h4><ul><li>打开上一步编辑的文件 <code>source/_data/styles.styl</code>，继续在下面增加如下内容</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 针对<span class="selector-tag">Code</span>代码标签的美化</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7254e</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f9f2f4</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="给网站底部增加访问者数量"><a href="#给网站底部增加访问者数量" class="headerlink" title="给网站底部增加访问者数量"></a>给网站底部增加访问者数量</h4><ul><li>编辑修改文件</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 找到 copyright 这一标签栏，然后在标签内部添加代码</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;copyright&quot;&gt;</span><br><span class="line"># ......这里已经有了一些配置</span><br><span class="line"># 在这里添加新的代码</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"># 添加后是这样：</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;copyright&quot;&gt;</span><br><span class="line">  # ......这里已经有了一些配置</span><br><span class="line">  # 在这里添加新的代码</span><br><span class="line">  &#123;%- if true %&#125;</span><br><span class="line">    &lt;<span class="selector-tag">span</span> class=&quot;post-meta-divider&quot;&gt;|&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span> class=&quot;post-meta-item-<span class="attribute">icon</span>&quot;&gt;</span><br><span class="line">      &lt;<span class="selector-tag">i</span> class=&quot;fa fa-user-md&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">    Visitors: &lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>重新生成预览修改后的效果，确认没问题后发布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"><span class="comment"># 确认没问题后发布</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="给仓库添加-README-md-文件"><a href="#给仓库添加-README-md-文件" class="headerlink" title="给仓库添加 README.md 文件"></a>给仓库添加 README.md 文件</h4><p>每个项目下一般都有一个 <code>README.md</code> 文件，但是使用 hexo 部署到仓库后，项目下的 <code>README.md</code> 文件会被覆盖，所以需要设置配置文件避免覆盖。</p><p>在 <code>Hexo</code> 目录下的 <code>source</code> 根目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br></pre></td></tr></table></figure><p>保存退出即可。再次使用 <code>hexo d</code> 命令部署博客的时候就不会渲染 <code>README.md</code> 这个文件了。</p><h4 id="几个常用插件"><a href="#几个常用插件" class="headerlink" title="几个常用插件"></a>几个常用插件</h4><ul><li>Hexo Filter MathJax：渲染数学公式<ul><li>安装 <code>npm install hexo-filter-mathjax</code></li><li>详细配置：<a href="https://github.com/next-theme/hexo-filter-mathjax">hexo-filter-mathjax</a></li></ul></li><li>Hexo Word Counter：文章字数统计<ul><li>安装 <code>npm install hexo-word-counter</code></li><li>详细配置：<a href="https://github.com/next-theme/hexo-word-counter">hexo-word-counter</a></li></ul></li><li>Hexo Optimize：优化博客加载速度<ul><li>安装 <code>npm install hexo-optimize</code></li><li>详细配置：<a href="https://github.com/next-theme/hexo-optimize">hexo-optimize</a></li></ul></li><li>更多插件：<a href="https://theme-next.js.org/plugins/">https://theme-next.js.org/plugins/</a></li></ul><h3 id="源文件备份"><a href="#源文件备份" class="headerlink" title="源文件备份"></a>源文件备份</h3><ul><li>切记备份好本地的源文件，尤其是 Markdown 文件，其他配置一旦丢失则无法正常写博客，需要从头开始设置</li><li>建议使用 GitHub 同一个仓库备份</li><li>建议每当有一些改动就备份一次，或者每日备份一次</li><li>更多用法请查看 <a href="https://git-scm.com/book/pl/v2/Appendix-C%3A-Git-Commands-Sharing-and-Updating-Projects">Git 文档</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加前面设置好的博客仓库地址</span></span><br><span class="line">git remote add https://github.com/your-name/your-name.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加并保存当前改动，并记录备注</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;源文件更新&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立并切换到新的分支</span></span><br><span class="line">git checkout -b <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地 source 分支的全部内容推送到远端仓库的 source 分支</span></span><br><span class="line">git push origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="用不同的电脑写博客"><a href="#用不同的电脑写博客" class="headerlink" title="用不同的电脑写博客"></a>用不同的电脑写博客</h3><ul><li>当在不同的电脑上写博客时，需要进行基础软件安装，再拉取远端备份 GitHub 的仓库到本地，进行博客的更新</li></ul><ul><li>下载安装 node.js （<a href="https://nodejs.org/en/">官网下载安装</a>）</li><li>下载安装 git （<a href="https://git-scm.com/downloads">官网下载安装</a>）</li><li>安装 hexo 框架: 打开 cmd 运行</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>进行本地更新</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库到本地</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/your-name/your-name.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果本地已经克隆，每次更新博客前都需要拉取最新分支内容</span></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到对应分支</span></span><br><span class="line">git checkout <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 hexo 配置下的全部插件后可以开始更新编辑博客内容</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容后记得及时备份一条龙</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;博客更新xxx&quot;</span></span><br><span class="line">git push origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布推送最新博客内容到域名站点</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g  <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo s  <span class="comment"># 本地预览博客效果</span></span><br><span class="line">hexo d  <span class="comment"># 发布最新博客内容</span></span><br></pre></td></tr></table></figure><h3 id="几个常用命令汇总"><a href="#几个常用命令汇总" class="headerlink" title="几个常用命令汇总"></a>几个常用命令汇总</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line"><span class="comment">#或 hexo generate，根据源文件生成静态网页</span></span><br><span class="line">hexo d</span><br><span class="line"><span class="comment">#或 hexo deploy，发布推送到 GitHub Pages</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment">#或 hexo server，本地部署测试</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 清空静态网页 cache，然后 hexo d 重新生成</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;你是不是早就厌倦了那些博客网站毫无美感的界面，是不是受够了无休无止的网站推送，是不是早就想建立一个属于自己的博客，却止步于复杂的教程以及一系列令人头疼的代码？那么恭喜你，这篇文章就是想以最浅显易懂的方式手把手教你搭建属于自己的博客，你只需要一点耐心，一步步跟着做。&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="博客搭建" scheme="https://philo-li.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>永恒的创作（一些推文）</title>
    <link href="https://philo-li.com/eternal-creations/"/>
    <id>https://philo-li.com/eternal-creations/</id>
    <published>2022-09-11T11:53:13.000Z</published>
    <updated>2024-04-14T06:02:42.119Z</updated>
    
    <content type="html"><![CDATA[<p>Eternal Creations (a series of tweets)</p><p>一些关于创作的思考。</p><span id="more"></span><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>孤独本来就是人间常态，我从来不会寄希望于其他人类能帮我解决这个问题，因为我知道没有人能真正帮我。我都孤独了二十多年，早就学会了如何自娱自乐，一切的能量都可以自给自足。最自由强大的人肯定不是从不感到孤独的人，而是拥抱孤独，能和孤独成为朋友的人。</p><p>当然还有一种，来自宇宙深处的孤独，是我这辈子都不想再体验的。仅仅体验过一次，自那以后，我就只想离人群近一点，再近一点。庆幸的是，我知道我不会再遇见那种时刻了，那时光被永远定格在了某段世界线当中，于我而言亦是一段永恒。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>似真似假，似梦如幻。电信号在繁复交错的神经通路中穿行。人每次回忆过去的时候，往往会篡改某些记忆，在潜移默化中大脑被逐渐重塑。我们实际上是用记忆来感知自己过去的存在，如此看来，过去的自己是真的都被永恒定格在历史中了吗，应该不是的，ta 们和此刻的自己，在所有空间和维度上，共同呼吸着。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>挣扎是永恒，抗争是永恒，困难也是永恒存在的，所以状态的反复也很正常。成长也意味着局部的破碎和重生，唯有死亡和永不成长才能带来长久的平静。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>我觉得我的人生就是一场追寻美的旅程，美妙的终极理论，美好的人格，美丽的风景，美味的食物……瞬间和永恒，平凡和伟大，真实与幻觉，善良与邪恶，屈服与抗争之中蕴含着的美。如果暂时找不到那我就自己雕琢自己，创造自己的作品。我是一名观察者，欣赏者，亦是一名创造者。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>一大群人热衷把自己的生物学 DNA 传递下去，而另一小群人想把自己的灵魂 DNA 传递下去，创作就是实现永生的途径。作品比肉体更永恒。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Eternal Creations (a series of tweets)&lt;/p&gt;
&lt;p&gt;一些关于创作的思考。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>未名情话</title>
    <link href="https://philo-li.com/a-love-letter-to-nobody/"/>
    <id>https://philo-li.com/a-love-letter-to-nobody/</id>
    <published>2022-08-27T11:53:13.000Z</published>
    <updated>2024-04-14T04:57:28.091Z</updated>
    
    <content type="html"><![CDATA[<p>写给不知名对象的情话，也是灵魂碎片。</p><span id="more"></span><hr><h4 id="《如果》"><a href="#《如果》" class="headerlink" title="《如果》"></a>《如果》</h4><p>如果可爱是美，那我便可爱。<br>如果真诚是美，那我便真诚。<br>如果勇敢是美，那我便勇敢。<br>如果善良是美，那我便善良。<br>如果智慧是美，那我便求知。<br>如果专一是美，那我便专一。<br>如果你就是美，那我便爱你，不求回报地。<br>若你天生就美，那我便天生爱你，发自内心地。 </p><hr><h4 id="《像欣赏一幅画一样欣赏你》"><a href="#《像欣赏一幅画一样欣赏你》" class="headerlink" title="《像欣赏一幅画一样欣赏你》"></a>《像欣赏一幅画一样欣赏你》</h4><p>我不想评判别人，也不想被人评判。我只想像欣赏一幅画那样去欣赏别人，在我眼中画没有高低贵贱，只分美与不美。</p><p>像欣赏一幅画那样，欣赏你的结构和色彩，你的纹理和质感，到底是千篇一律还是独一无二。像欣赏一幅画那样，欣赏你的优点和缺点，你走过的路看过的风景，你的快乐和忧伤，以及你费了多少心思，又如何细心且耐心地雕琢自己的人格。这些都可以是很美的。</p><p>忽然意识到，我爱的不是人，爱的也不是物，爱的是美而已。美学的美。 </p><hr><h4 id="《最浪漫的情话》（2020）"><a href="#《最浪漫的情话》（2020）" class="headerlink" title="《最浪漫的情话》（2020）"></a>《最浪漫的情话》（2020）</h4><p>「偷偷画你」，大概是一个画家能说出的最浪漫动人的情话了吧</p><hr><h4 id="《我是单线程动物》（2019）"><a href="#《我是单线程动物》（2019）" class="headerlink" title="《我是单线程动物》（2019）"></a>《我是单线程动物》（2019）</h4><p>我是单线程动物<br>哪有同时好几个心动女孩<br>只「喜欢你」一个进程<br>就已经跑满了我整个大脑</p><hr><h4 id="《无题》"><a href="#《无题》" class="headerlink" title="《无题》"></a>《无题》</h4><p>我发给你的每一个表情，每一句话，每一个晚安，以及我望向你的每一眼，都在说：我喜欢你。（2019）</p><hr><p>我有亲密关系恐惧症，我总是会介意和人类的肢体接触，但是，我想吻你，发自内心的。  （2019）</p><hr><p>我还是不会放弃寻找最纯净热烈的爱的！不互相占有，不含杂质，没有芥蒂，完全意义上的相互信任，是两个灵魂的彼此拥抱。看似平淡如水，但内心绝对炽热。我相信会有的。（2019）</p><hr><h4 id="《所谓真爱》"><a href="#《所谓真爱》" class="headerlink" title="《所谓真爱》"></a>《所谓真爱》</h4><p>人世间最珍贵的不过是一片真心，而真心之中最为难得的，便是能窥见他人灵魂的赤子之心。</p><p>为何真爱难得，很大一部分原因在于真心难觅。先要有真，然后还要有爱。有人只有真没有爱，有人只有爱却不够真，二者寓于一体才能达到真爱的境界。你要真，还要有可爱，所以你是真可爱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写给不知名对象的情话，也是灵魂碎片。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>如何获得天马行空般的想象力</title>
    <link href="https://philo-li.com/how-to-be-creative/"/>
    <id>https://philo-li.com/how-to-be-creative/</id>
    <published>2022-03-19T11:53:13.000Z</published>
    <updated>2024-04-14T04:45:59.689Z</updated>
    
    <content type="html"><![CDATA[<p>想象力每个人类都有，关键是不知道如何去发挥。我要回答的其实不是「如何获得想象力」，而是「如何释放你的想象力」，所以这里主要讲讲所谓天马行空的想象。</p><span id="more"></span><p>想象可以分两类，难度比较低的是「关于某意象的联想」，难度更高的是「讲故事」，即有头有尾有逻辑的联想。</p><h3 id="关于联想"><a href="#关于联想" class="headerlink" title="关于联想"></a>关于联想</h3><p>天马行空的想象并不是凭空产生的，而是需要引子。这个引子可以是某个记忆片段，大自然，某个人，某个声音，某本书，某部艺术作品等世间万物，也可以是另一个已完成的想象。想象可以是画面的联想，也可以是感觉气味和氛围的联想。</p><h3 id="简单相似联想"><a href="#简单相似联想" class="headerlink" title="简单相似联想"></a>简单相似联想</h3><p>将意象1和另一种看似不相关的意象2建立联系，最简单常见的就是画面的相似性。</p><p>举例：如可以像人&#x2F;拟人化、小动物、某风景等世间万物。</p><p>联想意象越通俗常见，就越能引发广泛的共鸣。比如用幼儿园小朋友也能理解的各种小动物、云、星星、大海等意象，就会表现出童真。 联想的意象如果需要一定的知识储备才能理解，比如联想到某个角色、名人、名画、知识点、梗等，就会显得硬核。</p><h3 id="通过排列组合进行创造"><a href="#通过排列组合进行创造" class="headerlink" title="通过排列组合进行创造"></a>通过排列组合进行创造</h3><p>通过改变引子的部分名称、局部形态、材质和功能等等，创造出全新的事物。</p><p>举例：马</p><p>不同形态：马+人：半人马兽，马脸人；马+鸟：带翅膀的天马；马+角：独角兽等等</p><p>不同材质：马+冰&#x2F;水：透明的冰&#x2F;水马；马+火：烈焰马；马+火+鸟：烈焰飞马；马+木头：木马；</p><p>马+机械：机械马；马+云：云马&#x2F;马云；马+风：风马等等</p><p>不同功能：马+各种超能力：各种超能力马，比如能变形、变色、飞天、遁地、穿越、说话等等</p><h3 id="逆转对比，制造反直觉-反物理定律的效果"><a href="#逆转对比，制造反直觉-反物理定律的效果" class="headerlink" title="逆转对比，制造反直觉&#x2F;反物理定律的效果"></a>逆转对比，制造反直觉&#x2F;反物理定律的效果</h3><p>大与小：巨大凶猛的怪兽和渺小无助的人类、温柔巨兽&#x2F;巨大猫咪和小朋友</p><p>强与弱：超能力女儿和麻瓜父亲、天敌成为了朋友、猫总是被老鼠欺负</p><p>硬与软：以为是硬的其实是软的&#x2F;以为是软的其实是硬的、外表坚硬但是内心柔软的机械人、外表柔软但内心冷血无情的人或动物</p><p>实与虚：眼前看似真实的事物是投影、真的一伸手就能摘到的星星和云朵、梦境是可以吃的，树长脚能跑……</p><p>拿云举例：一朵云要是变成宠物会怎么样，用根绳子就能牵着，像气球一样，还可以装扮；用宠物云的颜色来实时显示主人的心情怎么样；云竟然是硬邦邦的敲起来咣咣地响；云有性格，还有和人类社会相似的云朵帝国；人类中有猎云师专门猎云，抓起来驯化变成人的宠物、坐骑、奴隶……</p><p>真要一直这么头脑风暴下去可以没完没了，因为想象的规则就是如此简单，熟练掌握以上规则之后，看似天马行空的想象就可以有意识地批量生产了。还有种境界是让这些天马行空的想象在大脑中疯狂生长，比较不受控还特别劳神，相当于进入了一种纯粹的白日梦状态。</p><p>在前述联想的基础上，加上合理的逻辑和结构，就能创造出天马行空的故事。不过故事再天马行空，也脱离不开人，讲述的都是关于爱的事情，爱人或是爱真理爱自由。关于讲故事又是一个非常大的话题，也超出了本人能力，这里就不展开说了。</p><h3 id="什么是优秀的联想"><a href="#什么是优秀的联想" class="headerlink" title="什么是优秀的联想"></a>什么是优秀的联想</h3><p>想拥有丰富的想象力，只需要将以上规则内化于心，多多练习。创新就是举一反三，天马行空的想象也是创新的一种，道理大同小异，关键是到底能不能打破思维定势，把它运用到自己的实际生活当中。</p><p>只是单纯地进行简单联想非常容易，难一点的是将那些优秀的联想挑选出来，这就需要一定的审美能力，需要对联想进行有主题、有方向、有策略地选择。比如摄影师主要是在现实中挑选美的画面，画家在头脑&#x2F;现实中挑选美的画面，作曲家挑选出那些美的旋律。</p><p>也许依靠计算机的穷举法和上述基本规则，也能通过排列组合打造出无数作品，可你能说那些不加筛选的作品是美的吗？都有价值吗？蕴含着情感吗？能称得上是伟大艺术吗？很可能不是。也许从垃圾堆里也能淘到一点点有价值的东西，但更有可能就算等到太阳系消失，宇宙终结，我们的时间还不足以让我们从一堆随机数中挑选出一部莎士比亚的作品。那为什么不自己掌握规律，亲自去想象和创造呢？</p><p>优秀的联想应当是有趣的，能引发人的共鸣，要能打动人，还得是美的。有趣的联想应当要能给人带来“啊哈”时刻，看似简单而又不普通，处于意料之外又在情理之中。好的联想或者说创造，也应当是蕴含了更多想象空间的，能引发观众更多想象和不同解读的。能打动人的联想应当是真诚的，是善的，是蕴含着人类共通的本能情感的，或是能唤起人的愉悦体验，让人不自觉沉浸其中，或是唤起某种遥远记忆，激发某种崇高又神圣的体验，当人回过神来时已经饱含热泪。</p><p>擅长想象最多只能成为空想家，而最难的一步是将这些想象变成实在的作品，创造出来，这需要强大的执行力和耐心，也是各类艺术家们在做的事情。 想法是廉价的，珍贵的是行动力和执行力。做白日梦是简单的，几乎每个人都曾幻想过飞上天空，却没有几个人会真的去造飞机，而更难的是真的把能安全载人的飞机火箭造出来。</p><p>灵感固然重要，不过在翻越灵感的山峰之后，还有无数的险峰峻岭要跨越，要付出剩下 99% 的汗水，是考验体力、能力、素质的战斗，那是真正的高手对决，神仙打架。</p><p>想象也许是人类才拥有的特殊能力，愿我们都能更大胆想象，让天马行空的想象力丰富我们的生活，为我们创造的作品注入活力，丰富我们的情感体验，给我们带来更多快乐。</p><p>以上内容来自于我长期的观察思考和个人经验，主要源于两年前某个夜晚的头脑风暴的记录，也是本人对于想象力的一点理解，希望能给你带来一点启发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想象力每个人类都有，关键是不知道如何去发挥。我要回答的其实不是「如何获得想象力」，而是「如何释放你的想象力」，所以这里主要讲讲所谓天马行空的想象。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>人生游戏</title>
    <link href="https://philo-li.com/life-is-a-game/"/>
    <id>https://philo-li.com/life-is-a-game/</id>
    <published>2022-03-19T11:53:13.000Z</published>
    <updated>2024-04-14T04:35:15.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="把人生当作游戏"><a href="#把人生当作游戏" class="headerlink" title="把人生当作游戏"></a>把人生当作游戏</h3><p>有人战战兢兢如履薄冰，把人生当战场，稍微偏离预期就认为自己失败；有人没来得及探索自己真正的兴趣和擅长，就过早认定了一条最大众化的稳妥道路；有人一直做着不喜欢的工作，又无力改变现状，只会抱怨；有人一遍又一遍陷入各种情绪的泥潭无法自拔；有人只顾短期利益牺牲长远利益，以至于做出一个又一个非常不明智的决策……</p><span id="more"></span><p>为何不跳出框架思考，把人生当作一个不能读档的大型多人在线角色扮演游戏，用最认真的态度去玩耍。</p><hr><p>银行账户上变动的数字是游戏币<br>体检单上标着你的血条&#x2F;健康值<br>书本和互联网里有各种游戏攻略<br>WikiHow 是新手引导<br>Wikipedia 是游戏图鉴<br>书本里有通关高阶技巧<br>……</p><hr><p>有人追求最多的游戏币，有人追求排行榜留名，有人追求爱与被爱，有人翻山越岭想亲自看遍千山万水，有人愿意挑战终极困难实现自我，有人勇敢攀登智慧的高峰，还有人跟着感觉和兴趣四处游走，什么都想尝一尝看一看，有人选择在海上冲浪，还有人只想安居一角感受平淡最真……</p><p>你是谁，你想要什么，你的游戏目标是什么，你的主线和支线又是什么？只活一辈子又怎样，如果可以活十辈子你是不是还按现在这样活？</p><p>现代国人太焦虑了，似乎所有人眼中只有一条名为“成功”的道路，还没来得及好好感受生命给予的馈赠，就早早失去了玩耍的心态。人生明明可以有很多活法，有趣且值得的路线可以有很多。</p><p>如果想要自由那就追求自由，如果想要快乐那就追求快乐，如果想要智慧那就追求智慧，在身体和心灵上不停打磨自己。如果可以，为什么又不把目标设得高一点呢？取法于上，得乎其中；取法其中，得乎其下。</p><p>对我来说，生活就是一场游戏，值得探索地方还有很多，要摸索世界运行的规则边探索边实践，冒险般的生存方式会带来什么呢？谁知道，反正要一直向上看，别回头，拒绝无聊，还要学很多很多东西，努力成为自己眼中最闪闪发光的存在。</p><p>脚踏实地做事的时候，仍然不要忘记抬头仰望星空，如果可以，还是尽量做个有趣的人吧，这是我对自己的要求。</p><h3 id="还想说的话"><a href="#还想说的话" class="headerlink" title="还想说的话"></a>还想说的话</h3><p>疫情当下，有很大的概率现状就是新常态。在和平年代出生和成长的我们，这几年应该是我们长大至今经历的最黑暗的日子。不过再寒冷的冬天也会过去，再漫长的黑夜也会有结束的一天，寒冰会化，春天会来，明天的太阳还会照常升起，要如何度过这漫漫长夜，这是我们每个人都要思索的话题。</p><p>实在不忍看着无数人活在痛苦之中，封闭感受不去看不去想是我唯一的选择吗，我可以做一点什么吗，即便作为一个微不足道的存在，我也在想有什么是我可以做的。我想力所能及地点一把篝火，帮助大家创造一些连接，给予一些陪伴。让你知道你不孤单，这里还有很多人在这里陪伴。</p><p>祝我们在漫长黑夜还可以有星星作伴，还有火苗，和跳动的心脏。 </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;把人生当作游戏&quot;&gt;&lt;a href=&quot;#把人生当作游戏&quot; class=&quot;headerlink&quot; title=&quot;把人生当作游戏&quot;&gt;&lt;/a&gt;把人生当作游戏&lt;/h3&gt;&lt;p&gt;有人战战兢兢如履薄冰，把人生当战场，稍微偏离预期就认为自己失败；有人没来得及探索自己真正的兴趣和擅长，就过早认定了一条最大众化的稳妥道路；有人一直做着不喜欢的工作，又无力改变现状，只会抱怨；有人一遍又一遍陷入各种情绪的泥潭无法自拔；有人只顾短期利益牺牲长远利益，以至于做出一个又一个非常不明智的决策……&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>短诗合集（2019）</title>
    <link href="https://philo-li.com/collection-of-my-short-poems-2019/"/>
    <id>https://philo-li.com/collection-of-my-short-poems-2019/</id>
    <published>2020-01-02T11:53:13.000Z</published>
    <updated>2024-04-13T03:31:19.125Z</updated>
    
    <content type="html"><![CDATA[<p>有幻想，有现实，也有童真可爱，都是灵魂碎片。</p><p>姑且称之为短诗吧。</p><h3 id="幻想"><a href="#幻想" class="headerlink" title="幻想"></a>幻想</h3><p>《月亮》</p><p>月亮打了个喷嚏<br>打出了漫天繁星</p><span id="more"></span><hr><p>《马桶》</p><p>大海的神经末梢</p><hr><p>《无题》</p><p>鸟儿们在天空中游泳，鱼儿们在大海里飞翔。</p><hr><p>《太阳知道》</p><p>太阳知道我们怕黑<br>所以每到夜晚<br>它就会给我们点上<br>一盏月亮</p><p>太阳知道我们怕孤独<br>所以每回出现<br>它就会给我们带来<br>影子作伴</p><hr><p>《床》</p><p>床是时空穿梭机<br>闭上眼<br>你就能穿越到未来</p><hr><p>《阳光的味道》</p><p>吃到我们嘴里的每一口食物<br>其实都是阳光的味道</p><hr><p>《床》</p><p>开放式棺材</p><hr><p>《辣》</p><p>食物界 SM</p><hr><p>《食物》</p><p>食欲的刽子手</p><h3 id="童真"><a href="#童真" class="headerlink" title="童真"></a>童真</h3><p>《童趣》（其一）</p><p>余忆童稚时<br>能张目对日<br>然后我就瞎了</p><hr><p>《童趣》（其二）</p><p>余常于土墙凹凸处<br>花台小草丛杂处<br>蹲其身<br>定神细视<br>神游其中<br>然后起身我就倒了</p><hr><p>《童趣》（其三）</p><p>夏蚊成雷<br>或千或百<br>然后我就疯了</p><hr><p>《无题》</p><p>我这种偶尔连自己都会忘了喂的人<br>是不适合养小动物的<br>小动物养我还差不多</p><hr><p>《探险》（小故事，未完待续）</p><p>背一把宝剑<br>兜里揣着几颗糖果<br>跟着一只不停晃着尾巴的小狗<br>就可以出发去探险了</p><p>饿了就吃糖果，渴了就喝泉水，夜晚到了就找一棵很大很大的树，在树下点好火堆，和小狗一起靠近火堆躺着。看着漫天的星星，听着柴火的噼里啪啦，还有小狗的呼噜呼噜，不一会儿就睡着啦。</p><h3 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h3><p>《万事开头难》</p><p>万事开头难<br>生孩子除外</p><hr><p>《社交恐惧症》</p><p>对人类过敏</p><hr><p>《上班》</p><p>合法卖血</p><hr><p>《养老金》</p><p>年轻人的血</p><hr><p>《社会主义》</p><p>义务献血</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有幻想，有现实，也有童真可爱，都是灵魂碎片。&lt;/p&gt;
&lt;p&gt;姑且称之为短诗吧。&lt;/p&gt;
&lt;h3 id=&quot;幻想&quot;&gt;&lt;a href=&quot;#幻想&quot; class=&quot;headerlink&quot; title=&quot;幻想&quot;&gt;&lt;/a&gt;幻想&lt;/h3&gt;&lt;p&gt;《月亮》&lt;/p&gt;
&lt;p&gt;月亮打了个喷嚏&lt;br&gt;打出了漫天繁星&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Philo的脑洞合集（2019）</title>
    <link href="https://philo-li.com/collection-of-my-interesting-ideas-2019/"/>
    <id>https://philo-li.com/collection-of-my-interesting-ideas-2019/</id>
    <published>2020-01-02T01:53:13.000Z</published>
    <updated>2024-04-13T03:30:45.225Z</updated>
    
    <content type="html"><![CDATA[<p>你常常发呆吗？你发呆的时候都在想些什么？</p><p>人类冬眠了会怎么样？如何实现长生不老？如何变快乐？人类要是也有了叶绿体会怎么样？有没有外星人？为什么人要睡觉？什么是记忆？什么是性别？人类天生就会走路吗？为什么有人喜欢跑马拉松……</p><p>这些想法和疑问总在不经意间闯入我的大脑，在和网友的交流互动中，我也收获了诸多乐趣和非常有意思的回答，于是有了这篇年度合集。</p><p>愿我能一直像个孩子一样，保持好奇心，保持想象力。</p><span id="more"></span><p>推特最有意思的地方在于，我问癌细胞能不能做人造肉，能有人回「尝过并不好吃」；我问癌细胞能不能实现人类的长生不老，就有人推荐相关的小说和漫画；我提到性别的结构性压迫，能在讨论中看到有人提出更专业的论据。这种开放平台集思广益的能力相当棒，我也很乐意从一些看似普通的提问中，收获非常有价值的来自不同领域的回答，感谢热情的推友们。</p><h2 id="人类冬眠了会怎么样呢？"><a href="#人类冬眠了会怎么样呢？" class="headerlink" title="人类冬眠了会怎么样呢？"></a>人类冬眠了会怎么样呢？</h2><p>人类啊，进化了几十万年还没有进化出冬眠的能力，真是太落后了。</p><p>你看冬眠，节约了一大波耗费在取暖上的能源，还节约了大量食物，规避了在低温情况下人类工作和学习效率的低下造成的资源浪费。并且所有产业停工放假，全球碳的排放降至最低，生物圈开始重新循环。</p><p>等我们醒来的时候，春暖花开，各处空气质量都极佳，大家在最舒服的状态下开始了新的一年的工作学习生活。</p><p>每个国家可以根据自己的纬度安排冬眠日期，比如北半球冬眠时南半球在工作。一些需要交接的工作可以添加到冬眠人的待办事项中，让他每天醒一个小时或者每周醒一天，完成一些比较紧急的必要事务。</p><p>当大家都冬眠时，政府会留下很少量的一批人，以维护城市的日常安全，保障人类生命和财产安全，应对个别紧急灾害。其他日常琐事，比如道路清洁，可以用大量机器人；新闻记录收集，可以通过无人机自动进行拍摄、整理，作记录用也可供人们醒来阅读。</p><p>如果有外星人入侵、国家战争、大型自然灾害，会唤醒更多专业的部队去解决。<br>在额定的冬眠时间内，人们可以定制个性化的冬眠方案。比如下雪时就唤醒你和小伙伴出来玩雪；天气很好或者有奇观时唤醒你出来看风景；约定和某某同时醒来，就可以每次醒来都有人陪着一起玩。</p><p>还有适合减肥的安全健康的冬眠计划，通过冬眠时长以及营养摄入剂量调整，让你一觉醒来就拥有健康美丽的身材，为了保障冬眠人的健康，减肥计划的强度会有所限制……</p><p>如果人类开始冬眠，这对人类来说算不算好事不好说，但对地球来说一定是好事。</p><h2 id="当人类皮肤有了叶绿体"><a href="#当人类皮肤有了叶绿体" class="headerlink" title="当人类皮肤有了叶绿体"></a>当人类皮肤有了叶绿体</h2><p>如果通过转基因，让人类皮肤细胞都拥有叶绿体，那么人类是不是就不用吃饭也不用做饭了，喝一点无机物营养液，然后晒晒太阳就饱了。唯一的副作用就是你浑身都会变绿。</p><p>@yourcountry64：<br>不是。植物通过大量的分叉和广阔的叶片面积获得足够的光照，人体的表面积&#x2F;体积之比很低，使人没有足够的光合作用效率，偏偏人类又具有非常活跃的新陈代谢和巨大能量需求。如果人类可以进行光合作用，在阳光充足的一天，也无非提供人体总能量需求的百分之一以下而已。</p><h2 id="利用癌细胞实现长生不老？"><a href="#利用癌细胞实现长生不老？" class="headerlink" title="利用癌细胞实现长生不老？"></a>利用癌细胞实现长生不老？</h2><p>癌细胞是不受细胞凋亡机制限制的，只要有足够的养分，癌细胞可以无限生长和分裂下去，不会衰老和死亡。如果找到某种机制，把人的全身细胞都转化成癌细胞，同时做到一定程度地限制分裂，那么人类是不是就实现了长生不老？</p><p>可以研究癌细胞是如何打破细胞凋亡机制限制的，并应用到正常细胞上。因为目前只有癌细胞做到无限成长这一点，所以也可以研究如何让它恢复其他正常功能，来实现正常细胞不衰老的目的。</p><p>@EndlessNull:<br>那時候它應該就不叫癌細胞了（海拉细胞）</p><h2 id="利用癌细胞做人造肉？"><a href="#利用癌细胞做人造肉？" class="headerlink" title="利用癌细胞做人造肉？"></a>利用癌细胞做人造肉？</h2><p>能不能利用癌细胞的无限分裂来做人造肉？如果可以的话，那么我们是不是就有低成本且无限供应的肉食食品了？</p><p>@Reno_Lam：還是需要養分才能夠複製，而培養液的生產本身也是一個瓶頸。當然真要說的話，如果是人工培植的組織，其實現在就已經有辦法能夠解除細胞分裂的限制來讓它們快速（相對）增生了。因為現在動物細胞的培養液通常也是從動物（像是牛）提取出來的，所以lab-grown meat現在還不算是vegan食物（即使細胞源是能夠同意提供cell line來種肉的）</p><p>@hg4867：同样是细胞分裂，还是养猪既便宜又高效</p><p>@shijiejilupian：有個科幻小說叫《癌人》，还蛮有趣的</p><p>@dizzzzziness：癌组织吃起来像土，非常难吃</p><p>@eGUAbe2V7j26GHw：先生，这盘菜是您点的红烧前列腺癌….谁还吃得下去….</p><h2 id="社会化抚养幼儿"><a href="#社会化抚养幼儿" class="headerlink" title="社会化抚养幼儿"></a>社会化抚养幼儿</h2><p>如果让国家统一抚养所有新生儿，提供最优秀的保姆和育儿服务，给足爱和陪伴，保证身心健全。优生优育靠宣传。亲生父母需要通过评估，走领养手续才能领回孩子，后续保持跟进，一旦不达标就撤回，如果不通过就一直由政府抚养。那这样是不是可以最大化孩子的利益，培养出最健康的孩子？</p><p>统一抚养不是流水线生产，提供爱和陪伴除了护工另有他人，比如社区化&#x2F;大家庭制，一对指定的新父母同时照顾五六个孩子，其他想来领养的父母心有余力可以多领养几个。成本一部分来自税收，一部分来自向亲生父母强制收的抚养费，部分实在给不起抚养费的就国家负担。</p><p>愿意自己养的且有能力养的父母可以走领养流程来把孩子领回去，不领回去的基本都是父母养不了的没能力的，而且政府一样能提供优质父母能提供的一切，生活模式和一个有五六个孩子的大家庭一模一样，不是学校化管理也不是集中住宿，区别只在于他们和孩子之间没有血缘关系。</p><p>贴一下李颖老师的回答。我觉得这个角度很好，各种类型的小家庭最大的意义在于多元和自由，面对千变万化的环境，抗风险能力比起中央集权要强很多。（我的设想启发于「当父母不用考试」，想说如果加个考试会怎么样，正常情况绝大多数父母都能通过的，然而大家看到统一就走极端了）</p><p>@LiYing_2015：<br>推荐读一下《美丽新世界》。中央集权最大问题就是缺乏local information，官僚管制绝对无法应付千变万化的微环境，经济上中央集权就带来集体贫困，子女抚养中央集权就带来抗风险能力下降千百万倍，一旦出现预想外的情况就无法应付，于是全体灭绝，而人类社会和大自然的复杂度都是远超人类设计能力的，因此这种“意外”必然发生。<br>这就是自由的意义所在，每个人知道自己的、不同于他人的具体利益，并按自己的方式去应对，经济的自由就带来灵活性和繁荣，就好像生物学上多姿多彩的变异，才是唯一能够生存下去的方式。<br>社会和政治意义上的自由也有不亚于经济自由的重要意义，世界的变化经常是不同于历史的，因而无先例可循，无知识可供参考，无法预知，无法计划的，所以只有自由制度导致无穷无尽的变异，然后才有可能在未来的变化中留下幸存者的种子。</p><p>另一个很棒的思路。社会化抚养不一定就意味着专制，反而能解放年轻人，没有父权和家庭的压力，能让年轻人获得更多的自由选择空间。</p><p>@Searl_Scarlet：<br>托洛斯基在苏联一五计划的时候搞过一套过渡计划：将家务，育儿，食堂等等全部外包给公共福利机构处理。最终消灭家庭的经济职能从而消灭家庭。但是结果是由于资金不足该福利方案只在莫斯科周边执行，并在斯大林时代被取消了。（详见《被背叛的革命》）</p><p>@postmodernbrute:<br>你换个思路。社会化抚养不代表要政府提供「保姆和育儿服务」。比如可以由当地社区形成一个育儿互助组织，将抚养义务摊到整个社区上面。这样能避免很多问题。</p><p>虽然家庭制度历史源远流长，但随着社会进步，公民素质提升，生育率下降，国家和社区承担越来越多的育儿责任（参考发达国家各种鼓励生育的政策），单身生育越来越流行，说不定有一天家庭制度会完全解体。父母对小孩的影响越来越弱，也趋近于我所说的那种模式了，高度发达的文明社会还是有希望做到的。</p><p>很接近该设想的现实中的例子：SOS儿童村</p><h2 id="抓蚊子的机器蜻蜓"><a href="#抓蚊子的机器蜻蜓" class="headerlink" title="抓蚊子的机器蜻蜓"></a>抓蚊子的机器蜻蜓</h2><p>用仿生蜻蜓来抓房间里的蚊子怎么样？<br>没事儿就在房间里乱飞，静音还能旋停，头顶装一个迷你激光炮，功率不足以伤到家具但恰好能击落蚊子，蚊子落下后就捡起来丢到垃圾桶。不人道的话激光炮可以换成空气炮，只弄晕蚊子，再丢出窗外。其他时间蜻蜓就停在无线充电板上充电，同时留意房间动静。</p><p>@asaaoiokaeri:<br>可以改进一下，通过散发一种神奇的信息素使蚊子凑到蜻蜓身边来进行歼灭，还有就是对蚊子的智能识别（暴论）</p><p>@MapleYu_Neko:<br>姑且整理一下仿生蜻蜓需要的組件：</p><p>仿肌肉高強度馬達(或類似東西)<br>超輕薄韌性構材仿生翼<br>急速充放超級電容<br>微型激光發射系統 or 強力空壓機<br>室內定位系統<br>敵我辨識系統<br>取物爪裝置<br>無線充電板不一定必要，足做接點即可</p><h2 id="造梦机"><a href="#造梦机" class="headerlink" title="造梦机"></a>造梦机</h2><p>可以用「造梦机」解决临终关怀时期病人的精神问题？<br>造梦机可以直接干预人的意识，让人随时随地处于梦境中，在梦里帮助实现他们未竟的梦想，比如在梦里恢复健康、回到某个令人遗憾的记忆重新选择、环游世界等。反正都是将死之人，即使分不清现实和虚幻也问题不大。</p><p>@Qiolin_:To the moon的剧情诶 当时玩哭了</p><h2 id="互联网时空旅行"><a href="#互联网时空旅行" class="headerlink" title="互联网时空旅行"></a>互联网时空旅行</h2><p>100年以后，要是这几个主流社交网站还没死的话，互联网上将会出现非常多的数字坟墓。每个承载着它过去主人生活和记忆碎片的账号，在一轮又一轮的互联网浪潮中越埋越深。</p><p>到时候也许有人会开发出《百年数字时空旅行》项目，设立专门的网站或其他浏览通道，列出那些百年来最值得挖的数字坟墓，并给大家指路。</p><p>这里有聚光灯下的名人，也有众多平凡人，这里是最佳的人类观察窗口。你在这里能事无巨细地看到，一个孩子从呱呱坠地到他慢慢老去，最后一条是代发的讣告。瞧瞧，百年前人的喜怒哀乐和今天有多么相似，这一个个曾经鲜活地跳动过的个体，真是有趣。</p><p>ta在很认真地活。ta在很努力地死。</p><p>他们还会堵车？真不敢相信。<br>他们手里那玩意儿是不是叫「手机」？我在我爷爷家里见到过。<br>网速是什么东西？</p><h2 id="为什么人要睡觉？"><a href="#为什么人要睡觉？" class="headerlink" title="为什么人要睡觉？"></a>为什么人要睡觉？</h2><p>睡觉的必要性在哪？人类是否可以发展成不睡觉也能得到良好休息？</p><p>体力恢复在清醒状态下坐着&#x2F;躺着也能做到；睡眠状态大脑依然活跃，只是在整理，那是不是也能发展成醒着整理？动物每天睡觉的习惯是不是因为天黑了无事可做才形成的？北极熊晚上还看得见吗，在极夜天天睡觉还是会出来觅食？</p><p>我知道目前睡觉有它的必要性，但要是拉长时间尺度，是否能进化出不睡觉也能得到良好休息的个体。因为我也很好奇，从进化的角度看，睡眠状态下DNA修复效率高、整理记忆这些特质，会不会是因为动物先有睡觉的习惯（睡着了无事可做），大脑才故意将这类工作的工作时间从任意时刻转移到睡眠状态下的。</p><p>@ZenithFZH:<br>應該是先有清理需要發展出類睡眠的活動（大量生理機能關閉的一個狀態）在進化中逐漸固定下來<br>人的每一個內臟器官都有清理的需要吼 但是我比較關注的是離子這塊，比如說你喝濃茶喝多了心臟會不舒服，就是鈉超標了跟睡眠缺乏差不多的原因。大腦也需要恢復鈉鉀平衡，動力系統要回歸原點<br>(@philo2018:不过一定要关闭大量生理机能才能实现清理么？为什么不进化成一边醒着一边清理？)<br>其他器官也有需求的啦，就比如肝和腎他也有工作要做，他會受到交感&#x2F;副交感神經&#x2F;上行激動通路等等的制約，如果要保持緊張狀態的話就沒辦法實現</p><p>@yourcountry64：<br>极夜就是冬天了，北极熊冬天当然是在冬眠几个月。</p><p>@sumail666<br>能量再生。看到过一种角度：睡觉是进入宇宙（消耗巨大），醒着劳作只会为它积累能量。</p><p>@googollee:<br>反过来，大脑复杂程度增加，需要停机维护，进化出睡觉。<br>一本书: 為什麼要睡覺？</p><h2 id="多维世界"><a href="#多维世界" class="headerlink" title="多维世界"></a>多维世界</h2><p>我们会不会是和五维、六维、……十一维生物生活在同一个空间，和他们共同呼吸着，但是因为我们的观察能力所限，所以只能看到自己。</p><p>他们是我们没有办法想象的存在，正如纸片人想象不出立体世界。我们当前所观察到的宇宙已经是难以想象的大了，但每增加一个维度又等于多了无数个宇宙🤔……</p><p>维度造成的影响有没有可能是因果论的影响？（一个猜测）<br>观察能力又是怎么呈现的，两个不同方向的线形成平面，两个不同方向的平面形成空间，那么两个方向不同的空间形成四维空间，由此往下推导。不同的选择可以看成由一个空间转换到另一个空间（对世界产生了影响），而高维的生物有没有可能还是我们</p><p>@asaaoiokaeri:<br>维度造成的影响有没有可能是因果论的影响？（一个猜测）<br>观察能力又是怎么呈现的，两个不同方向的线形成平面，两个不同方向的平面形成空间，那么两个方向不同的空间形成四维空间，由此往下推导。不同的选择可以看成由一个空间转换到另一个空间（对世界产生了影响），而高维的生物有没有可能还是我们?<br>(@philo2018:有可能。我们其实生活在其他维度，只不过因为思维限制，只能看到三维世界的自己（投影）)<br>哇，投影这个词太形象啦。兴奋！！！！！！！！！！就是这样的，因为无法直观观测到，就会觉得我们的生命是线性的</p><p>@muzi_ii:<br>推荐一部法国科普纪录片《维度：数学漫步》<br>B 站上有双语字幕版的</p><h2 id="人类天生会走路吗？"><a href="#人类天生会走路吗？" class="headerlink" title="人类天生会走路吗？"></a>人类天生会走路吗？</h2><p>走路是人类纯后天习得的技能还是写在基因里的技能呢？</p><p>很多动物一生下来就会跑，为什么人生下来不仅不会走路，还要教啊？如果不特意教婴儿走路，那他能自学成材么？如果他在封闭空间长大，从来没见过人走路，是会长成个残疾还是突然就会走路了？</p><p>@gloriousgobid:<br>小孩子生下来不仅不能走路，连坐起来和翻身都做不到，因为身体的肌肉骨骼和神经系统都没有发育到那个程度。小孩要经历翻身，坐起，爬，站立，无搀扶走路几个过程，这些过程其实不需要教，他自己到了时候就会做到。</p><h2 id="关于记忆"><a href="#关于记忆" class="headerlink" title="关于记忆"></a>关于记忆</h2><p>人是靠记忆组成的，而不是靠观点组成的。你也许可以在地球上找到一个和你在每一件事情上的立场观点都一致的人，但ta无法替代你，你也无法替代ta，因为你们各自拥有着不同的记忆。</p><p>倘若你有一天失忆了（不可恢复），延续过去的感情不再有必要，因为你已经获得了重生，算是另一个人了。</p><p>你的记忆组成了你。如果你的记忆中只有仇恨，那么你便是仇恨，如果你的记忆中只有快乐，那么你便是快乐，如果你的记忆中只有爱，那么你便是爱本身。</p><p>@stoneyshow:<br>这与御前大宰相提里昂・兰尼斯特的《who has better story》学说不谋而合啊</p><h2 id="关于性别"><a href="#关于性别" class="headerlink" title="关于性别"></a>关于性别</h2><p>性转群体（MtF&#x2F;FtM）到底是无法接受自己的身体（性器官），还是无法接受性别带来的一系列影响，比如社会对不同性别的期待和枷锁？</p><p>如果一个社会完全不歧视任何性别，所有人都能按照自己的兴趣自由发展，工作一视同仁，一切性别气质都不会被歧视，那么还会有 trans 么？</p><p>@tianna0026:<br>性转群体就是认知上认为的自己的性别和生理上的性别不同所以才要变性的。我觉得可以说社会规范或是社会上的影响多少影响了他们的想法，但不是主要原因。主要原因还是来自身体。</p><p>@h121040:<br>以自己為案例，曾有想變成扶他妹子的想法，想要有妹子的外表、聲音，也想要有兩者的性器，畢竟自己感受過男性部分的刺激同時也很好奇女性的刺激是什麼感覺，可能我是在比較開放的環境長大的吧，朋友對此都是抱著做自己的想法，總之天生的扶他我才要，既然現在是男的就順其自然。</p><h2 id="秃头话题"><a href="#秃头话题" class="headerlink" title="秃头话题"></a>秃头话题</h2><p>秃头话题只是最近两年特别火，还是在十年前也（一直以来都）这么火？</p><p>@asaaoiokaeri:<br>十年前计算机技术还没那么发达，就算搞这玩意的秃头，也传播不出去。就像南北差异，也是近几年才这么火，但是这些问题一直都存在。是我们才开始关注这些问题吗？可能是因为之前交通不算很发达，来南方读书的北方人很少，同理来北方读书的南方人也少，就没那么多共鸣</p><p>@SamuelsLilin:<br>一个话题可以长期持续要观察它本身进入视野的时代性，时效性，社会趋势和关注点，用magi搜索一下值得注意的是霸王洗发水，为何慢慢成为趋势应该是在这几年熬夜和程序员用脑过度的调侃，进而变成市场需求和互联网名词属性，谢顶基因的显著性也是构成它目前基本属性的条件之一，10年前和现在还是有差异<br>(@philo2018: 是不是也可以理解成，虽然秃头问题一直存在，但近几年确实有变更严重的趋势。因为移动互联网的发展，夜生活有了更多消遣的途径，而且996工作模式的流行，导致熬夜的人数与过去相比是有明显增加的。另外程序员数量的增加，活跃在互联网上的他们遇到的（秃头）问题也更容易成为互联网热点。)<br>我其实不认为是生理上的秃发在最近几年变严重了，而是群体的声音可以互相交流彼此找寻共鸣，他们的声音和需求创造了市场形成了联系，互联网在推进的这个过程，赋予了秃顶发量变少更多的含义，而社会产生的压力和环境带动的因素让大家观察身边和自己是不是真的因为某些原因出现掉发秃头的问题</p><h2 id="人为什么要活着？（一个悲观角度的解释）"><a href="#人为什么要活着？（一个悲观角度的解释）" class="headerlink" title="人为什么要活着？（一个悲观角度的解释）"></a>人为什么要活着？（一个悲观角度的解释）</h2><p>人活着就是为了打发时间。</p><p>所谓运转良好的社会就是，在通过工作保证自己不饿死的前提下，大家还有余力发展爱好来打发时间；所谓改变世界就是，要么发现了一种新的打发时间的方式，要么帮助了很多人更快乐地打发时间；所谓探索未知就是，吃饱了撑的，想找点没人玩过的东西来打发时间。</p><p>所谓发展爱好就是，让打发时间的过程没那么无聊；所谓恋爱就是，找个人陪你一起打发时间；所谓交朋友就是，找一群人陪你一起打发时间。</p><p>所谓衡量一个人的价值就是，计算到底有多少人花费了多少时间在你本人或你创造的东西上。总时间越长，就可以说这个人贡献的价值越大。比如开创新领域让无数后人去研究的人、写出让无数后人反复阅读研究的经典著作的人、创造了YouTube、Twitter的人、造出iPhone的人等等。</p><h2 id="为什么梦中的一切都显得无比真实？"><a href="#为什么梦中的一切都显得无比真实？" class="headerlink" title="为什么梦中的一切都显得无比真实？"></a>为什么梦中的一切都显得无比真实？</h2><p>在梦中出现的事物、场景、设定，不论有多么离奇荒诞，当你身处其中，从不会怀疑这一切的逻辑与合理性，而是对其深信不疑，并被动体验着剧情的推进。</p><p>我想，也许是因为梦与现实各有其完备的世界观，梦中出现的一切都符合那套新的已被你内化的世界观，因此你会觉得一切都合情合理，也会感到无比真实。</p><h2 id="认知偏差"><a href="#认知偏差" class="headerlink" title="认知偏差"></a>认知偏差</h2><p>为什么电视剧里坏人变好能圈一大波粉，但如果是好人变坏就会很容易遭人唾弃？但按照双方实际做的坏事来评估的话，坏人做的坏事要远远多过好人。这算不算是人类被感情蒙蔽的一个例子？</p><p>@softlips1024:<br>在资本市场上也有类似的情况：如果持有的股票之前一直涨现在突然跌了一点点，虽然总体来说还是赚但投资者会很后悔；如果之前一直跌现在突然涨了一点点，虽然总体来说还是亏但投资者会很开心。在行为金融学中，这种现象叫心理账户（Mental accounting），指人们非理性地把利得和损失区分开来看待。<br>(@philo2018: 啊我想起来了损失厌恶！应该是一个道理。)<br>是的，人在面对收益和损失时候的风险偏好程度是有显著差异的。比如打牌打麻将赢了的人会觉得今天到这里就好，输了的人总想继续因为觉得没准会回本。这个新兴学科挺有趣的，现在还在完善之中，学术界也是争论不休。</p><p>@EoyWVGbVYr1NXuP:<br>单说故事的创作，我的感觉是坏人更容易让人共情和激发观众自恋的拯救者心态;同理，(同样的创作能力下)好人更难塑造，很多时候是好人塑造的不够好。社会学方面的另说</p><p>@Yvonne520:<br>想起另外一个说法。好人要经历九九八十一难才能成佛，坏人只要放下屠刀就能成佛了。</p><h2 id="为什么男人的话不可靠？"><a href="#为什么男人的话不可靠？" class="headerlink" title="为什么男人的话不可靠？"></a>为什么男人的话不可靠？</h2><p>俗话说「男人的嘴，骗人的鬼」，和女性相比，男性的话真的如此不可靠吗？要真的是这样的话，从进化和基因传递角度，是不是男性靠骗才能最大化自己的利益？因为女性是生育主体，所以女性在这方面并不需要高超的技巧？</p><h2 id="为什么有人喜欢跑马拉松？"><a href="#为什么有人喜欢跑马拉松？" class="headerlink" title="为什么有人喜欢跑马拉松？"></a>为什么有人喜欢跑马拉松？</h2><p>喜欢跑马拉松的人是怎么想的？如果是为了健康，完全没有必要专门跑马拉松，有很多更轻松简单的健身方式。如果是喜欢竞争和比赛倒是可以理解。除了喜欢竞争，马拉松还能给人带来什么特殊的东西吗（主要指情感上）？</p><p>@milachatu:<br>随着马拉松在各大中小城市县城的推广，参加马拉松俨然成了一项时髦的运动，推广的媒体只说健身，坚持就是胜利，却鲜有提及如果身体不适应该立即停下来否则可能引发横纹肌消失等危及生命的症状。在这个过程中，媒体与城市获得了影响力，参与者填补了生活的空缺。</p><p>@yourcountry64:<br>和吃辣一样的，坚持跑步可以达到内啡肽上瘾。</p><p>@godfatherincape:<br>其实就是多巴胺的作用，再加上一点点成就感，剩下的就是可以一个人享受孤独</p><p>@GuogySakura:<br>是一个扩展生命的广度和深度好方式。对普通人来讲从5公里加量加到42公里是一件超复杂的系统工程，还可能会死。</p><p>@wu_xiaoshun:<br>获得一种精神上的优越感.作为一种朝圣的态度，内心的洗礼，完成比赛对自己有重要的意义。马拉松可以成为人们的精神寄托，逃避现实。</p><h2 id="大型在线合作项目-一起来写小说"><a href="#大型在线合作项目-一起来写小说" class="headerlink" title="大型在线合作项目:一起来写小说"></a>大型在线合作项目:一起来写小说</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;你常常发呆吗？你发呆的时候都在想些什么？&lt;/p&gt;
&lt;p&gt;人类冬眠了会怎么样？如何实现长生不老？如何变快乐？人类要是也有了叶绿体会怎么样？有没有外星人？为什么人要睡觉？什么是记忆？什么是性别？人类天生就会走路吗？为什么有人喜欢跑马拉松……&lt;/p&gt;
&lt;p&gt;这些想法和疑问总在不经意间闯入我的大脑，在和网友的交流互动中，我也收获了诸多乐趣和非常有意思的回答，于是有了这篇年度合集。&lt;/p&gt;
&lt;p&gt;愿我能一直像个孩子一样，保持好奇心，保持想象力。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Hello 2020</title>
    <link href="https://philo-li.com/hello2020/"/>
    <id>https://philo-li.com/hello2020/</id>
    <published>2020-01-01T11:53:13.000Z</published>
    <updated>2024-04-12T15:11:32.640Z</updated>
    
    <content type="html"><![CDATA[<p>一年的结束听起来略显伤感，而新年的开始就给人一种充满希望和活力的感觉，所以我总将「Hello XXXX」作为年度总结的标题，这是该系列博客的第二篇。</p><p>很多人的一生中难免要逃离点什么，有人逃离父母家庭，有人逃离学校，有人逃离朋友……而我在过去的一年里主要在做一件事，那便是逃离时间。</p><span id="more"></span><p>这一年我做了什么？<br>简而言之就是，什么也没做。</p><p>所谓逃离时间，说好听点叫做不愿随波逐流，说不好听点叫做不务正业，做一名社会闲散人士。不想遵从「毕业就该工作」这样的逻辑，我需要对自己的人生有掌控感，需要从工作中找到除了赚钱之外的其他意义，否则被时间的洪流强行推着往前走，只会燃烧我对生活的热情。</p><p>这一年我来到了杭州，开启了真正的独居生活，我拥有了大段的不被打扰的独处时光，有了面对自我的机会。</p><p>期间我有幸找到了一份远程兼职，虽说仍是入不敷出的状态（主要我的工作意愿不是很强烈），但这成为了我的一颗定心丸，让我即使没收入也能心安理得地潇洒度日。（真正没让我饿死的，还是支付宝和京东金条，笑。）</p><p>独居的日子像是在过退休生活，一切都变得非常慢。每天花好几个小时胡思乱想，看书写字画画散步，在推特上自言自语，花很多时间审视过往人生，偶尔和朋友聚会，约陌生人拍照。也感受着寒来暑往，每日的风云变幻。</p><p>在自我审视的过程中，我得到了一个非常重要的结论：我一直以为自己很缺爱，并且在很长一段时间内认为自己不值得被爱。但实际上不是这样，我能成长得这么好，这么乐观自信充满快乐，那一定是被爱滋养着长大的。我收获过来自家人、朋友、同学、老师的爱，还有很多陌生人的爱，虽然接触过的人不算很多，但是我遇到的他们总是友善又可爱。我自觉已经相当幸运，并时刻感激着这一切。</p><p>我感受到自己充满力量，</p><p>正如推友 @wjianjvn 的推文所述：所以人生最重要的任务就是重心整合过去的人生经验，在这些人生经验中找到那些来自父母和家人爱的证据，对那些来自他人的关心和帮助心存感激之情，这样的经历可以重新使你生活在联系和爱之中，让你重新获得自信和安全感，然后义无反顾的去探索人生的意义和不确定性。</p><p>我想，我可以迈向下一个阶段了。</p><p>我想做什么？<br>这一年来，我一直会时不时地问自己，我真正想要什么，我真正想做的事情是什么？至少在好几个月的时间里，我的答案都是：我不想工作（笑）。</p><p>我的终极目标是不工作，其次是自由职业，再次是远程工作，最后才是朝九晚五上班。我希望有一天靠不务正业也能养活自己。</p><p>其实这一年我还坚持做了一件事，就是每天发冷知识，除了这个月有点懈怠平均两天一条，之前一直是每日更新，从未中断，至今累计300多条。别人的冷知识账号需要投稿才能保持每日更新，而我一个人就能做到，因为对万事万物的好奇心就是我的日常。</p><p>我想做的，就是想一直去体验，去学习各种有用的没用的知识和技能，像这样一直保持无穷的好奇心，了解更多我身处的这个世界，学会爱更多的人，爱更多的事物，这也是Philo这个名字的含义。如果顺便能给其他人带来快乐和能量，那便是我最大的福气。</p><p>我还希望能帮助到别人，想让更多人爱上阅读，也想让他们体会到求知的乐趣；我想激发人们对未知事物的好奇心，帮助他们找到心中所爱，燃起对生活的热情；我想让他们知道，这个世界上有趣的事物还是有很多的呀。</p><p>我可以做什么？<br>我很清楚自己不想当一枚螺丝钉，我需要从工作中找到乐趣和价值感，我想成为一名内容创作者。</p><p>目标过于空泛是没有意义的。现阶段对我而言，切实可行的目标便是成为一名泛科普视频博主，用动画的形式科普人文、社科、自然科学等一切知识。这即符合了我爱给人科普的兴趣，也能发挥我无穷的好奇心以及涉猎广泛的优势，我依然可以做我最喜欢做的事情，并且这还是我所向往的自由职业状态，我想这样的工作再适合我不过了。</p><p>作为一名重度拖延患者，我也不知道什么时候才会有正式的产出，毕竟我想做出非常高质量的内容，对标那些最优秀的YouTuber们。目前还在补充计划的细节阶段，不过大方向已经确定了，度过了迷茫阶段，相信未来可期。</p><p>这一年的另一个巨大收获是，读书从一种普通消遣的方式变成了我真正的爱好。</p><p>这一年共计读了65本书，主要是社科类的，希望接下来再接再厉，涉猎更多不同的学科。</p><p>去年说过的话，今年再次送给自己。</p><p>GoodBye 2019，Hello 2020，新的一年我也希望能继续按照自己喜欢的方式去生活（去年我有做到哦）。</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>不要把你的心固定在转瞬即逝的事情上：因为在哈里发的部落灭绝之后，底格里斯河，仍将继续穿过巴格达而流淌。如果你富有，那就应该像枣树一样慷慨施与；而如果没有什么可以施与，那就像柏树一样做一个自由的人吧。<br>《瓦尔登湖》</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>相关阅读：<a href="https://philoli.com/hello2019">Hello 2019</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一年的结束听起来略显伤感，而新年的开始就给人一种充满希望和活力的感觉，所以我总将「Hello XXXX」作为年度总结的标题，这是该系列博客的第二篇。&lt;/p&gt;
&lt;p&gt;很多人的一生中难免要逃离点什么，有人逃离父母家庭，有人逃离学校，有人逃离朋友……而我在过去的一年里主要在做一件事，那便是逃离时间。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>拖延了五年我终于读完了《拖延心理学》</title>
    <link href="https://philo-li.com/book-procrastination/"/>
    <id>https://philo-li.com/book-procrastination/</id>
    <published>2019-09-13T15:25:20.000Z</published>
    <updated>2024-04-12T14:22:21.448Z</updated>
    
    <content type="html"><![CDATA[<p>买了快五年的书，一直拖延着没看完，现在终于一次性读完了。</p><p>为了方便阅读和理解，前面有不少是对书中内容的归纳总结，小标题基本是重新拟的。书中内容还是挺多的，举的例子也多，这里只是把一些最有价值的最关键信息提取出来，显得脉络更清晰一点，也能方便那些不想看原书的人。</p><span id="more"></span><h2 id="拖延怪圈"><a href="#拖延怪圈" class="headerlink" title="拖延怪圈"></a>拖延怪圈</h2><p>每个拖延者都会经历的一个拖延周期：（太真实了）</p><p><strong>1.「这次我想早点开始」</strong><br>刚接到一个任务时你总是信心满满，总觉得这次肯定能以一种有条不紊的方式将它做好。</p><p><strong>2.「我得马上开始」</strong><br>最佳启动时机已经过去，压力增加，但离最后期限还是很远，所以依然乐观。</p><p><strong>3.「我不开始又怎么样呢」</strong><br>又过去了一会儿，你还是没有行动，大脑开始打架：</p><p>a.「我应该早点开始」<br>发现自己浪费了太多时间，陷入悔恨和自责。<br>b.「我可以做任何事，除了这件……」<br>这个阶段，你什么都愿意做，如整理房间，但就是不做最该做的那件。保持忙碌，给自己一种正在认真推进工作的错觉。<br>c.「我无法享受任何事情」<br>你想通过一些愉快的活动分散注意力，如看电影、社交，但这种短暂的娱乐很快就会被负罪感和忧虑取代。<br>d.「我希望没人发现」<br>过去了很长时间，事情毫无进展，你开始感到惭愧，通过表现出自己的忙碌，来避免他人知道你的糟糕处境。</p><p><strong>4.「还有时间」</strong><br>临死之前仍然试图保持乐观，希望能出现缓刑的奇迹。</p><p><strong>5.「我这个人有毛病」</strong><br>奇迹没有出现，你绝望了。你认为自己可能缺少别人都有的某些东西 — 自我约束力、勇气、头脑或运气。</p><p><strong>6.「最后的抉择：做还是不做，战斗还是逃跑」</strong></p><p><strong>选择一：不做</strong><br>a.「我无法忍受了」<br>想在仅剩的时间里完成任务已经不可能了，同时还承受着巨大的痛苦和折磨，于是你逃跑了。<br>b.「别费劲了」<br>这么短的时间里反正做不好，做了也是浪费时间，就不做了吧。</p><p><strong>选择二：做</strong><br>a.「我不能再坐等了」<br>干坐着等死太痛苦，还是做点什么吧。<br>b.「事情还没有这么糟，为什么我不早点开始做呢」<br>开始以后，你发现原来的拖延和痛苦是不必要的。<br>c.「把它做完就行」<br>和时间赛跑，只求把事情做完。</p><p><strong>7.「我永远不会再拖延了」</strong><br>不论这个任务是否被完成，在经历了这个磨难后，你再一次下定决心，下次不再踏入这个怪圈，直到下一个任务出现……</p><h2 id="你为什么拖延？"><a href="#你为什么拖延？" class="headerlink" title="你为什么拖延？"></a>你为什么拖延？</h2><h3 id="1-为什么拖延：恐惧失败"><a href="#1-为什么拖延：恐惧失败" class="headerlink" title="1.为什么拖延：恐惧失败"></a>1.为什么拖延：恐惧失败</h3><p>「他们担心被他人评判或自我评判，害怕自己的不足被人发现，害怕付出最大努力还是做不好。」</p><p>「他们把表现好坏当作衡量一个人能力好坏的唯一标准，表现好即能力强，自我价值感越高，表现不好则证明自己没有能力。」</p><p>拖延者相信：自我价值感 &#x3D; 能力 &#x3D; 表现</p><p>拖延打破了上面第二个等号。不论表现好坏，他们都可以自我安慰说，表现不好是因为拖延，而不是能力差。</p><p>「有些人宁愿承受拖延所带来的痛苦后果，也不愿承受努力之后却没有如愿以偿所带来的羞辱。」</p><p>解决思路：如何看待失败<br>一般人面对失败主要有两种心态，固定心态和成长心态。</p><p>固定心态认为，能力和智力是与生俱来的，一切的挑战都是为了证明你的能力出色。而拖延是一种自我保护，可以避免这样的证明，即避免证明自己的能力不行。</p><p>成长心态认为，能力不是固定的，而是可以变化和发展的，可以通过努力变优秀。你没必要立刻擅长某件事情，而且做一件你不擅长的事情反而会更有趣，在其中你可以学习并且拓展自己。你的表现不能反映你的个人价值，你更该关注自己学到了什么。成败不能决定一个人能力的好坏，失败是让一个人加倍努力的理由，而不是让你退缩、放弃和拖延的理由。</p><p>这里更应该提倡的是成长心态。</p><p>正如德威克说的，「成功是为了学习和进步，还是为了证明你聪明？」</p><h3 id="2-为什么拖延：完美主义者"><a href="#2-为什么拖延：完美主义者" class="headerlink" title="2.为什么拖延：完美主义者"></a>2.为什么拖延：完美主义者</h3><p>拖延者往往会有这几类完美主义心态：</p><p><strong>a.「对自己的期待过高，不够现实」</strong><br>常常会定下自己做不到的高标准。</p><p><strong>b.「无法忍受平庸」</strong><br>无法忍受平庸，想要自己做的每一件事都非常出色。拖延可以让一个平常的表现归因于时间仓促，而不是自己能力不行。</p><p><strong>c.「认为优秀不用努力」</strong><br>完美主义者相信，对一个真正出色的人来说事情即便再困难也应该手到擒来。一旦无法做到这一点，他们的努力就会戛然而止。</p><p><strong>d.「拒绝求助」</strong><br>他们认为任何求助都是软弱的表现，即便求助会提高效率，他们也选择事事亲力亲为，直到负担变重。</p><p><strong>e.「0或100」</strong><br>只要项目未完成，对他们来说就是一无所成，所以在到达终点之前放弃就变得理所当然了。</p><p>对多数完美主义者而言，成就远不只达成目标或能力出众。在很多家庭中，表现出色似乎是赢得认可和爱的最可靠的方式。成就的价值高于一切，而其他次于它的表现不值一提、毫无价值。</p><p>对另一类完美主义者，一直被批评和低估，从没享受过赞许，通过表现完美来赢得尊重是他们唯一的希望。</p><h4 id="解决思路：不必事事追求完美"><a href="#解决思路：不必事事追求完美" class="headerlink" title="解决思路：不必事事追求完美"></a>解决思路：不必事事追求完美</h4><p>应该转变自己的心态，没有必要事事追求完美，允许自己犯错，也不要无限放大那些小错误，犯错很正常，一切都没那么糟糕。</p><p>将自己的固定心态转变为成长心态，用全新的眼光看待那些不完美，这不是致命打击，而是提升自己、学习成长的最佳推动力。</p><h3 id="3-为什么拖延：害怕成功"><a href="#3-为什么拖延：害怕成功" class="headerlink" title="3.为什么拖延：害怕成功"></a>3.为什么拖延：害怕成功</h3><p>担心获得成功需要付出太多努力，远远超出了他们的承受能力，他们认为自己达不到这样的要求，于是选择拖延来逃避。</p><p>担心成功之后被暴露在聚光灯之下，人们会加大对他的期望。为了满足这样的期待，他不得不给自己加压，变成工作狂，以至失去对生活的主动权，比如缺少和家人朋友相处的机会。通过拖延降低成功的机会，好让自己不被众人注目，有更多的自由。</p><p>害怕成功会伤害到别人，因为难免会有竞争。（其实人没那么容易受伤）</p><h4 id="解决思路：没必要担忧"><a href="#解决思路：没必要担忧" class="headerlink" title="解决思路：没必要担忧"></a>解决思路：没必要担忧</h4><p>成功不是一蹴而就的，而是需要脚踏实地一步步的行动。当你对目标更清晰明确，明白完成一个目标不是遥不可及之后，也就不会害怕成功了。</p><p>获得成功与失去对生活的掌控权并不是非此即彼的关系，会有家人朋友理解你，会为了你的成长和进步开心。很多担忧只是主观猜测，其实并不会发生。</p><h3 id="4-为什么拖延：反抗规则，争夺主动控制权"><a href="#4-为什么拖延：反抗规则，争夺主动控制权" class="headerlink" title="4.为什么拖延：反抗规则，争夺主动控制权"></a>4.为什么拖延：反抗规则，争夺主动控制权</h3><p>拖延常常成为了一个人的独立宣言，一个人试图通过拖延来告诉人们，「我是一个拥有自主权的人。我根据自己的选择来行动。我么有必要按照你的规定或者要求来做事。」</p><p>他们用拖延来逃避控制，反权威，反抗那些不得不遵守的规则。他们希望能按照自己的想法生活，保持独立自主性。他们用不合作的程度来增强自我价值感，即越拖延表示越独立越不受控制，自我价值感越强。</p><p>潜意识中把世界当作了战场，把每个人都看作有潜在控制欲的对手。他们可能从小被严格管束，个人习惯被过度干预，他人强烈的好奇心让他们感受到侵犯，不断的批评让他们失去自信，太多的限制压制了他们的自发性和创造性。</p><p>认为合作就意味着投降，合作仿佛是被逼迫着违背自己的意愿而做出的妥协。阻碍对方比得到自己想要的更为重要，这成为了你的重心，以至于超过了其他一切考虑。</p><p>拖延也被用来拒绝某个请求。</p><p>有人通过赶DDL来寻求刺激。</p><h4 id="解决思路：不是所有的规则都需要反抗"><a href="#解决思路：不是所有的规则都需要反抗" class="headerlink" title="解决思路：不是所有的规则都需要反抗"></a>解决思路：不是所有的规则都需要反抗</h4><p>当你产生了抵制的冲动，可以反思一下，这样的反应是否有必要。有时候你的抵制是有道理的，确实有人想约束你、控制你。但也有很多时候，你的抵制情绪来自于自身的恐惧，即这时候并没有人要控制你。</p><p>一个请求不一定意味着控制，一个规则不一定是无法逃脱的牢房，而与人合作也可能是一件令人开心的事情。</p><h3 id="5-为什么拖延：调节人际关系的亲疏"><a href="#5-为什么拖延：调节人际关系的亲疏" class="headerlink" title="5.为什么拖延：调节人际关系的亲疏"></a>5.为什么拖延：调节人际关系的亲疏</h3><p><strong>a.害怕疏远</strong><br>对人有依赖，无法独立做事，希望前面一直能有一个引路人。用拖延增加亲近，希望临死前有人来拯救自己，有理由向人求助。</p><p><strong>b.害怕亲近</strong><br>用拖延拒绝，以避免和他人太亲近，保持距离和边界感。也为了避免被人抢功劳占便宜。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><p>拖延也许可以暂时性地调节和他人的亲疏关系，但治标不治本，拖延只会让你失去心灵获得成长的机会。</p><p>人际关系中遇到问题和矛盾应当勇于面对，多沟通交流。维持一个良好的关系，同时保持依赖性和独立性的平衡是可以做到的，也相当重要。</p><h3 id="6-为什么拖延：时间观念问题"><a href="#6-为什么拖延：时间观念问题" class="headerlink" title="6.为什么拖延：时间观念问题"></a>6.为什么拖延：时间观念问题</h3><p><strong>a.客观时间和主观时间冲突</strong><br>不能很好地调和主观时间和客观时间，时间感弱，感觉未来总是遥遥无期，只活在当下。人与人之间的时间观念差异也会容易产生矛盾。过于注重当下轻视未来，影响长期计划的设立和实施。</p><p>不要活在主观时间中，要学会接纳客观时间，与之和谐相处。</p><p><strong>b.对抗时间，拒绝长大，拒绝变老</strong></p><p>生活总是在推着你走，毕业、工作、结婚、生子、退休，你想通过拖延来找回对时间的掌控感和主动权。你不想承认自己已经长大，不想承认自己在变老，似乎一直拖延下去，死亡也能推迟到来。</p><h4 id="解决思路：接受现实"><a href="#解决思路：接受现实" class="headerlink" title="解决思路：接受现实"></a>解决思路：接受现实</h4><p>但你终究会长大，时间总在流逝，死亡是逃不掉的，你要学会接受这个残酷的事实。</p><h3 id="7-为什么拖延：习惯成自然"><a href="#7-为什么拖延：习惯成自然" class="headerlink" title="7.为什么拖延：习惯成自然"></a>7.为什么拖延：习惯成自然</h3><p>一朝被蛇咬，十年怕井绳。可能你小时候缺乏鼓励或遇到了创伤，经历次数多了，对应的大脑神经通路被强化。后来再遇到同样的事情，你的恐惧会下意识地被激发，于是开始用拖延来回避。</p><h4 id="解决思路：建立并强化新的神经通路"><a href="#解决思路：建立并强化新的神经通路" class="headerlink" title="解决思路：建立并强化新的神经通路"></a>解决思路：建立并强化新的神经通路</h4><p>大脑是可塑的，你要识别出让你不舒服的源头是什么，面对它，建立并强化新的神经通路。</p><h3 id="8-为什么拖延：病理层面"><a href="#8-为什么拖延：病理层面" class="headerlink" title="8.为什么拖延：病理层面"></a>8.为什么拖延：病理层面</h3><p>执行功能障碍、注意力缺失综合征（ADD&#x2F;ADHD）、抑郁症、焦虑症、睡眠问题等等。</p><h4 id="解决思路：-1"><a href="#解决思路：-1" class="headerlink" title="解决思路："></a>解决思路：</h4><p>有病治病。</p><p>睡眠问题：要认识到自己到底是早起动物还是夜行动物，有的人早晨效率高，有的人夜晚效率高，应当顺应自己的身体模式，建立合理的计划，做到事半功倍。</p><h3 id="如何战胜拖延症？"><a href="#如何战胜拖延症？" class="headerlink" title="如何战胜拖延症？"></a>如何战胜拖延症？</h3><p>战胜拖延症的关键是识别出让自己拖延的根源是什么，面对它，基本思路上面都已提及。</p><p>具体方案无非就是时间、精力管理，老生常谈的内容了：（本书后半部分都在讲这个，废话多）</p><ul><li>目标别定太高</li><li>将大项目拆分成多个可执行的小项目</li><li>利用碎片时间</li><li>保持自信</li><li>不必事事追求完美</li><li>学会拒绝</li><li>将不重要的任务分配给他人</li><li>合理奖励自己</li><li>改变工作环境</li><li>多运动</li><li>睡眠充足</li><li>保持快乐</li></ul><p>祝大家早日战胜拖延症！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;买了快五年的书，一直拖延着没看完，现在终于一次性读完了。&lt;/p&gt;
&lt;p&gt;为了方便阅读和理解，前面有不少是对书中内容的归纳总结，小标题基本是重新拟的。书中内容还是挺多的，举的例子也多，这里只是把一些最有价值的最关键信息提取出来，显得脉络更清晰一点，也能方便那些不想看原书的人。&lt;/p&gt;</summary>
    
    
    
    <category term="日常阅读" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="读书笔记" scheme="https://philo-li.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>别再吹捧教师这个职业了</title>
    <link href="https://philo-li.com/do-not-flatter-the-teachers/"/>
    <id>https://philo-li.com/do-not-flatter-the-teachers/</id>
    <published>2019-09-10T11:53:13.000Z</published>
    <updated>2024-04-12T15:10:28.316Z</updated>
    
    <content type="html"><![CDATA[<p>在教师节这天，在几乎全中国都在忙着给老师送礼、赞美老师的今天，请允许我唱个反调。</p><span id="more"></span><p>说点政治不正确的，老师不过是另一份职业罢了，同样是拿钱干活，为什么就特别要令人尊重？</p><p>会讲课的好老师我见过，垃圾老师我也见过，但对我影响极大甚至能到改变我的人生的老师我没遇到过。上课是老师的本分，课上得好可以是敬业，但各行各业都有敬业的人，为什么老师就特别值得感恩？</p><p>如今师范生门槛很低，我过去看隔壁班那些抄作业的、经常逃课的、话都说不利索的，不敢想象他们有一天也要去当老师。大多数情况下老师面对的是心智未成熟的学生，现代教师基本不存在育人了，只要能教书就行，更别说很多老师连教好书都做不到，而且一个垃圾老师还可能毁了孩子的一生。</p><p>不管老师再怎么强调，偏心是必然的，面对众多学生，能受到老师重点关注的无非是好学生和差生，而这其中最容易滋生腐败。给老师送礼的、塞红包的、请老师做家教的家长，不要太多。甚至听说有些学校的老师，光明正大向家长收红包，并且按照红包金额大小分配对学生的注意力，也是长见识了。</p><p>这种对教师的无差别吹捧和美化还会带来什么问题？容易让心智未成熟的小孩&#x2F;他的家长过度信任一名陌生人，老师在他们眼中变成了比父母还神圣的存在，父母的话可以不听，老师的话一定会听。但是又有谁统计过，教师里面到底潜伏了多少恋童癖？缺乏性教育的中国，每天要发生多少起房思琪式的悲剧？</p><p>小学六年级，一个老师生孩子去了，就调来一外省中年男老师来代课。他除了在上课的时候经常对调皮的学生大骂「要是在我们那，我早就一脚踹过去了」，还喜欢一边摸着小女孩的手一边给她讲题。我忘记自己有没有被摸了（不是最受宠的那个），然而当时大家什么也不懂，最多只是私下调侃，并不会认为这行为严重，也完全不会联想到性骚扰。现在想想还挺恶心的。</p><p>别说未成年了，成年大学生也会遇上教师利用职务之便性侵的，利用成绩&#x2F;毕业证施压的，强迫学生免费替他打工的。不过这种权力不被约束的情况，也不是只有教师才有，以权谋私几乎在国内任何一个有权力的地方都能看到，是中国的通病了。</p><p>你可以赞美和感谢给你带来帮助的某个具体的人，但这种对某个职业的无差别的美化和吹捧，真的没必要。</p><p>没错，可以有伟大贡献的个体（伟大个体不太合适，造神运动不可取），但不应该有伟大的职业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在教师节这天，在几乎全中国都在忙着给老师送礼、赞美老师的今天，请允许我唱个反调。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>我对于“还愿”被封杀的看法</title>
    <link href="https://philo-li.com/my-view-on-devotion-being-blocked/"/>
    <id>https://philo-li.com/my-view-on-devotion-being-blocked/</id>
    <published>2019-02-26T11:53:13.000Z</published>
    <updated>2024-04-12T15:12:20.888Z</updated>
    
    <content type="html"><![CDATA[<p>声明：请理性讨论。赤烛团队已经对这场风波道了歉，现在我去试着谈论事件本身，并进行一点思考。</p><h2 id="首先，发生了啥？"><a href="#首先，发生了啥？" class="headerlink" title="首先，发生了啥？"></a>首先，发生了啥？</h2><p>《还愿》是台湾赤烛团队的最新的游戏作品，在刚发售两天的时候，被爆出游戏中一个印章涉嫌辱骂国家领导人，团队在第一时间道歉并替换了素材。但是在短时间内舆论发酵，从印章脑补到整个游戏都涉嫌辱华，引发了全员抵制行为，很多购买游戏的人冲进steam退款并疯狂刷差评。最后游戏在一天内被国内全网封杀，steam国区也下架了这款游戏。</p><span id="more"></span><h2 id="赤烛团队对这场风波有没有责任？"><a href="#赤烛团队对这场风波有没有责任？" class="headerlink" title="赤烛团队对这场风波有没有责任？"></a>赤烛团队对这场风波有没有责任？</h2><p>责任肯定有的，毕竟如果没有那张贴图什么事情都不会发生。</p><h2 id="赤烛团队有没有错？"><a href="#赤烛团队有没有错？" class="headerlink" title="赤烛团队有没有错？"></a>赤烛团队有没有错？</h2><p>我认为没有错。嘲讽国家领导人在任何一个民主国家都是被允许的，并且大家天天开玩笑，早就习以为常，加入该素材的人也没有想很多。按照五年前的政治环境，大家若是看到这样的彩蛋，肯定会是相视一笑，会觉得有趣，根本不会当回事。就算是今天，在网络上也存在着各种各样的调侃性质的表情包、文章、评论等等。我们的红线一天天收紧，赤烛没有义务去了解界限到底在哪里。我们应该反思的是制度的问题，而不是在瞬间将矛头转向制作组。</p><h2 id="什么叫做“夹带私货”？"><a href="#什么叫做“夹带私货”？" class="headerlink" title="什么叫做“夹带私货”？"></a>什么叫做“夹带私货”？</h2><p>我最早是在别人翻译著作的时候听过这种说法，说的是译者在翻译他人著作的时候故意添加自己的理解，有的甚至扭曲了原文意思的行为。而整个《还愿》本就是赤烛团队的原创作品，全是“私货”，哪里还有“夹带私货”这一说呢？</p><h2 id="有没有辱华？"><a href="#有没有辱华？" class="headerlink" title="有没有辱华？"></a>有没有辱华？</h2><p>游戏中最多就是出现了一个印章彩蛋，辱华纯粹是脑补，制作组也已经解释并道歉过了。<br>欲加之罪，何患无辞？相似的场景在文革期间也出现过，没错是文字狱。</p><p>脑补游戏辱华的人是这样讲的：<br>杜美心 &#x3D; 向着美国的心<br>陆恭铭 &#x3D; 陆公民（暗指大陆公民）<br>陆心社 &#x3D; 大陆心就是邪教<br>分数 89 暗示某著名事件<br>蜡烛 49 代表 1949<br>1987&#x2F;10&#x2F;1~1987&#x2F;10&#x2F;7 暗示国庆</p><p>实际上很多网友还这样脑补：<br>杜美心 &#x3D; dmx &#x3D; 大明星<br>美心 &#x3D; “迷信”的台语发音<br>陆恭铭 &#x3D; “路光明”的台语发音<br>陆心社 &#x3D; X心社、X心会、X心教的说法在台湾很常见<br>89，49 这种两位数在台湾一般指民国年，不是公元年<br>因为仪式是 7 天，而且 1987&#x2F;10&#x2F;7 日是当年的中秋节，这一天还出现了半影月食。中秋节不能合家团聚，家庭破裂，是一种游戏暗示。同时月食在宗教文化中本来就表示大凶，妖魔鬼怪都会出来，将这一天作为仪式的最后一天也增加了游戏的恐怖气息。</p><p>所以所谓辱华言论纯粹是脑补过度。</p><h2 id="嘲讽国家领导人等不等于嘲讽整个国家？"><a href="#嘲讽国家领导人等不等于嘲讽整个国家？" class="headerlink" title="嘲讽国家领导人等不等于嘲讽整个国家？"></a>嘲讽国家领导人等不等于嘲讽整个国家？</h2><p>不等于。天天有人骂特朗普的，外国人嘲讽美国人自己也嘲讽，而美国人根本不会觉得这是在骂整个美国。一个人不应该成为一个国家的象征，这也是在现代民主国家建设中要极力避免的现象。然而在这次风波中，我看到了有相当一部分人，就是抱着这样的态度，在触发开关后开启了疯狂模式。</p><p>现在的言论环境收紧，只是未曾有人料到，环境竟然已经恶劣到如此地步。发售三天大波好评，然后有人爆出印章，继而一堆人就开始脑补各种影射，觉得自己被侮辱了，再上升到国家层面，就说游戏辱华了。瞬间开始了大规模的“抵制运动”，发帖咒骂的，在各种相关视频底下刷屏劝下架的，涌入steam退完款再给差评的，最后游戏在半天内被国内全网封杀。</p><p>或者说环境还没有恶劣到如此程度，而是重压之下大家的自我审查程度竟然到了如此地步。</p><h2 id="艺术到底应不应该掺杂政治？"><a href="#艺术到底应不应该掺杂政治？" class="headerlink" title="艺术到底应不应该掺杂政治？"></a>艺术到底应不应该掺杂政治？</h2><p>总有人说，游戏&#x2F;文学&#x2F;电影&#x2F;音乐等就是要“纯粹”，不应该加政治。不好意思，艺术从来没有远离过政治，非常多优秀的艺术作品内容与政治息息相关。艺术本应当拥有最大的自由，可以充分地去表达，包括人性释放，也包括政治批判。一边说着艺术不能谈论政治，另一边政治随意插手艺术（影视剧、书籍、游戏等的审查），本就是相当分裂的行为。艺术可以谈论政治，而且应该谈论政治，艺术的批判方式比普通说教更能深入人心，艺术应当尝试用自己的力量打破加在身上的限制。</p><h2 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h2><p>steam的《还愿》讨论区刚经历完两天的刷屏，积累了几千条疯狂的帖子，也逐渐开始冷却下来。从标题中也能明显感知到，新增的大部分帖子基本都是理性讨论帖了，纷纷开始思考背后的原因，两岸网友开始探讨双方的政治观点差异等等。而很多台湾人表示，他们不认为调侃领导人是什么严重的事情，比如网民或者媒体骂蔡英文简直是家常便饭，早就习惯了，反而看大陆人因为一点事情如此大动干戈觉得有点好笑。</p><p>而且你不喜欢一款游戏，你个人可以退款可以给差评，这一点问题也没有。但是你不能因为个人的喜好去绑架全体人，并反对其他人玩。这种全员疯狂抵制疯狂刷屏的现象，正不正常，是不是过头了？如果不正常，这背后的疯狂到底是哪里出了问题？</p><p>反思体制，反思教育，才是我们更应该做的。</p><p>你说政治理你很远，而且你不喜欢政治，所以也不想看。<br>实际上政治和你的生活息息相关。你发现看到一半的电视剧突然下架了，发现喜欢看的耽美小说被禁了，发现刚刚发的微博被删除了，发现关注了很久的博主账号突然不见了，查一点资料看到“根据相关法律法规不予显示”，发现你的见义勇为可能要面临牢狱之灾，发现给孩子买的奶粉里有三聚氰胺，发现孩子上的幼儿园有三种颜色，发现刚打的疫苗已经过期了，发现父母买了一大堆权健的保健品，发现自己陷入金融骗局投诉无门，想要上访的时候发现自己被加入了黑名单限制乘坐高铁，发现看到的世界一团糟打开电视却一片祥和处处歌功颂德……政治其实就是你的衣食住行，你离不开政治。政治不只是政府，还有法治体系，监督制度，以及全体公民。你也应当认识到，我们在课堂中接收到的政治教育是缺失的，甚至是扭曲的，那些要求背诵的无聊段落不配称为政治。<br>说这一段的目的是想让大家不要把政治当作恶魔，政治离你很近，大家能做的是学会监督，行使公民权利。因为以后成为各行各业一把手的人可能是你的同学，想让环境变好的的方式除了监督别人，还有约束自己。</p><p>以上只是我的一点不成熟的想法，如果你有想说的，欢迎理性评论，观点一致和观点不一致都可以。</p><p>后记：在朋友圈发文字的截图，尝试了四次都发不出去，对“还愿”两个字进行打码后也是一样，所以干脆放弃了。还是直接放一个博客链接比较令人神清气爽。</p><p><strong>相关阅读推荐：</strong><br><a href="https://theinitium.com/article/20190227-notes-devotion">《還願》爭議的兩重模糊：遊戲表達的意義與「被侮辱」主體</a><br>(来自“端传媒”的读者来函，阅读需要翻墙)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;声明：请理性讨论。赤烛团队已经对这场风波道了歉，现在我去试着谈论事件本身，并进行一点思考。&lt;/p&gt;
&lt;h2 id=&quot;首先，发生了啥？&quot;&gt;&lt;a href=&quot;#首先，发生了啥？&quot; class=&quot;headerlink&quot; title=&quot;首先，发生了啥？&quot;&gt;&lt;/a&gt;首先，发生了啥？&lt;/h2&gt;&lt;p&gt;《还愿》是台湾赤烛团队的最新的游戏作品，在刚发售两天的时候，被爆出游戏中一个印章涉嫌辱骂国家领导人，团队在第一时间道歉并替换了素材。但是在短时间内舆论发酵，从印章脑补到整个游戏都涉嫌辱华，引发了全员抵制行为，很多购买游戏的人冲进steam退款并疯狂刷差评。最后游戏在一天内被国内全网封杀，steam国区也下架了这款游戏。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Hello 2019</title>
    <link href="https://philo-li.com/hello2019/"/>
    <id>https://philo-li.com/hello2019/</id>
    <published>2019-01-01T11:53:13.000Z</published>
    <updated>2024-04-12T15:11:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>在微博上看到有人写出充满想象力的很可爱的诗句，觉得也太棒了吧，原来诗也可以这样写，想学！</p><p>在推特上看到一名日本的年轻画家的画作，觉得画面也好情感表达也好想象力也好，都太精彩了吧，我也想尝试，将自己脑海里的画面表达出来！</p><p>前两天看星际迷航，知道了克林贡语，是制作组特意为了剧里的外星人创造的语言，甚至提供了该剧的克林贡语字幕。而且克林贡字典已经卖出超过 25 万本，Google 搜索引擎还有克林贡语的版本，多邻国甚至提供了该语种的课程。心想，能够把科幻周边发展到这份上，也太酷了吧！想学！</p><span id="more"></span><p>这两天看 My Brilliant Friend ，被 Lila 的气质吸引，感叹她们之间微妙的友谊，还觉得意大利语怎么这么好听，想学！</p><p>诸如此类还有很多，这就是我的日常，每隔几个月就会打开一个新世界的大门。</p><p>即便绝大多数时间我都是独自呆着，但是我完全不会感觉到所谓无聊和寂寞，因为有趣的事物是如此之多。我会对一切我未知的事物产生好奇，想要去尝试，去了解，想去学习一切我认为很酷的事情。</p><p>当然，我对于“酷”的定义与常人不太一样，我认为只要是我觉得有趣的就是酷的。比如我觉得看很多书的人很酷，我觉得写诗的人很酷，能画出好看的画的人很酷，能拍出好看照片的人很酷，能拍出好看的电影和电视剧的人很酷，能写出很多优秀软件的人很酷，能说出新颖观点的人很酷，愿意自由表达自己想法的人很酷，愿意挑战权威的人很酷。也许其他人不一定这么想，但我觉得自己也很酷。</p><p>刚进大学的时候我也是充满热情，后来在环境的潜移默化中，老师的照本宣科中，杂七杂八的毫无意义的管理条例下，热情逐渐丧失殆尽。</p><p><strong>我可以毫不负责任地说，中国普通大学就是扼杀学生好奇心和学习热情的地方，那不是教育，不过是换一个地方继续管理。</strong> 在我看到所谓中国顶尖高校面对类似年初的沈阳事件后的做派，看到北大对于那些敢于站出来为工人维权的北大学子的打压，取缔马会，就觉得，呵，所谓名校也不过如此，同样乌烟瘴气。当最应当倡导自由和正义的大学校园中不允许出现自由的时候，我就已经对这类学校非常失望了。</p><p>毕业之后的这几个月，有充足的时间面对自己之后，我又逐渐找回了自我，找回了那份原本属于自己的好奇心，那份对于未知事物的热情，探索的欲望，尝试的动力。我想去看更大的世界，想表达自我。</p><p>我时不时会写点什么，80% 是为了表达， 20% 是为了交流。不是为了标新立异特立独行，只是有时候一些想法若是不记录下来，就会一直萦绕在脑海中，一天两天，一周两周，久久不能散去。想交流，又害怕交流，害怕自己不知道如何回应。</p><p>我认为表达自我不一定要拘泥于某种形式，有时候我用文字，有时候是绘画，还有摄影，也尝试写诗，以及写程序，未来也可能去拍一些几分钟的视频，只是想用最合适的方式、更能传达内心的想法的方式去表达。不一定要被多少人看到，但还是至少会希望有那么几个观众。</p><p>我从小写作文就拿不到高分，也没学过画画，刚开始折腾摄影，但是我一点也不害怕去尝试，不害怕被笑话，因为我的目的更多地是在于表达，而不是表现。说实话，我这个只要不讲话就没有人会注意到我的人，存在感极低的人，能被看到就很难得了。也正因为存在感低，没有出众的才华和外貌，也没有一大堆朋友推不掉的聚会，没有多余的关注，我获得了比其他人更大的自由，能够自由地行动和思考。</p><p>我自己购买 VPS 搭建 VPN ，这样我就能看到一个更大更精彩的世界。我看教程学习搭建博客，给博客添加小功能并搭建图床，这样我就能随心所欲地书写，不用考虑敏感词不需要担心被删贴被封号。我学习数据科学，机器学习，准备当数据方向的程序员，计算机是万能工具，有了它我就能做到很多原来不能做的事。</p><p>我想知道世界是如何运转的，为什么我们看到的世界是这个样子，想知道外星人到底存不存在，想知道马斯克是不是真的会移民去火星；想知道不同的文化是如何形成的，不同的制度是怎样演变的，贸易到底在国家之间扮演着怎样的角色，为什么会有战争，黑市到底是怎样形成的，为什么大多数历史时期女性地位都处于弱势常常被压迫；想知道人类为什么有喜怒哀乐，性格到底是天生因素比较多还是后天影响比较多，基因到底有哪些奥妙，为什么有婚姻以及婚姻制度是否合理，为什么有如此多的性倾向，福柯的书里到底说了些什么……</p><p>因为好奇，因为想知道，这些是我活下去的动力，所以我想尽量活得久一点，知道的就能多一点。</p><p>我对社会很绝望，每天看那些社会新闻，除了难过和愤怒我不知道自己还能做什么。为什么还有如此多的人在受不合理的压迫，为什么他们还没有等到属于他们的正义降临，为什么人性可以如此邪恶，为什么他们可以喝人血可以喝得理所应当，为什么那些自己的血正在被人喝着的人还要咒骂那些不想喝血并且呼吁大家不要喝的人，为什么被统治者被训练成为了动不动就要站在统治者角度思考问题的人。我很难过，我很愤怒，我还想知道这些问题的答案。</p><p>人类就是矛盾的集合体。我对社会很绝望，但仍然可以对生活对世界充满热情，这是我在这个令人绝望的环境下让自己的灵魂不死去的途径。</p><p>网络是我的双眼，亦是我的双腿，他能带我去到我暂时不能去到之处，能让我看到在各个角落闪闪发光的人，能让我领略不同文化并感受不同观点间的碰撞。</p><p>GoodBye 2018，Hello 2019，新的一年我也希望能继续按照自己喜欢的方式去生活。</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>我们只对未知的事物产生畏惧，知道越多，畏惧越少。<br>by Lila 《我的天才女友》</p>            <i class="fa fa-quote-right"></i>          </blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在微博上看到有人写出充满想象力的很可爱的诗句，觉得也太棒了吧，原来诗也可以这样写，想学！&lt;/p&gt;
&lt;p&gt;在推特上看到一名日本的年轻画家的画作，觉得画面也好情感表达也好想象力也好，都太精彩了吧，我也想尝试，将自己脑海里的画面表达出来！&lt;/p&gt;
&lt;p&gt;前两天看星际迷航，知道了克林贡语，是制作组特意为了剧里的外星人创造的语言，甚至提供了该剧的克林贡语字幕。而且克林贡字典已经卖出超过 25 万本，Google 搜索引擎还有克林贡语的版本，多邻国甚至提供了该语种的课程。心想，能够把科幻周边发展到这份上，也太酷了吧！想学！&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>数据科学中 Python 的常用语法(进阶)</title>
    <link href="https://philo-li.com/python-tutorails-advanced-level/"/>
    <id>https://philo-li.com/python-tutorails-advanced-level/</id>
    <published>2018-11-07T14:53:13.000Z</published>
    <updated>2024-04-13T05:17:19.064Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在看这本 <a href="https://book.douban.com/subject/26364377/">Data Science from Scrach</a> (<a href="http://www.zhanjunlang.com/resources/tutorial/Data%20Science%20from%20Scratch%20First%20Principles%20with%20Python.pdf">PDF地址</a> )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。<br><a href="https://philoli.com/python-tutorails-basic-level/">数据科学中常用的 Python 语法(基础)</a><br><a href="https://philoli.com/python-tutorails-advanced-level/">数据科学中常用的 Python 语法(进阶)</a>  </p><p>本章侧重于介绍在数据处理中非常有用的 Python 进阶语法和功能（基于 Python 2.7 ）。</p><span id="more"></span><h3 id="排序-Sorting"><a href="#排序-Sorting" class="headerlink" title="排序 Sorting"></a>排序 Sorting</h3><p>如果你想对 Python 的列表进行排序，可以使用列表的 <code>sort</code> 方法。如果你不想破坏原列表，可以使用 <code>sorted</code> 函数返回一个新的排好序的列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = <span class="built_in">sorted</span>(x)       <span class="comment"># y = [1,2,3,4], x 不变</span></span><br><span class="line">x.sort()            <span class="comment"># 当前 x = [1,2,3,4]</span></span><br><span class="line">sort 或 <span class="built_in">sorted</span> 是默认从小到大对列表进行排序的。</span><br></pre></td></tr></table></figure><p>如果想让它从大到小排序，可以指定一个 <code>reverse = True</code> 的参数。</p><p>也可以自定义排序函数，让列表按照指定关键字进行排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照绝对值从大到小排序</span></span><br><span class="line">x = <span class="built_in">sorted</span>([-<span class="number">4</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>], key=<span class="built_in">abs</span>, reverse=<span class="literal">True</span>) <span class="comment"># is [-4,3,-2,1]</span></span><br><span class="line"><span class="comment"># 按照单词出现的次数从大到小进行排序</span></span><br><span class="line">wc = <span class="built_in">sorted</span>(word_counts.items(),</span><br><span class="line">key=<span class="keyword">lambda</span> (word, count): count,</span><br><span class="line">reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="列表解析-List-Comprehensions"><a href="#列表解析-List-Comprehensions" class="headerlink" title="列表解析 List Comprehensions"></a>列表解析 List Comprehensions</h3><p>我们会经常遇到这样的情况，想要提取列表中特定几个元素组成新的列表，或是改变其中几个元素的值，或者皆有。Python 中的惯用做法就是 列表解析（List Comprehensions） :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># [0, 2, 4]</span></span><br><span class="line">squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]                 <span class="comment"># [0, 1, 4, 9, 16]</span></span><br><span class="line">even_squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> even_numbers]        <span class="comment"># [0, 4, 16]</span></span><br></pre></td></tr></table></figure><p>类似地你可以将列表变成字典或集合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square_dict = { x : x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) }       <span class="comment"># { 0:0, 1:1, 2:4, 3:9, 4:16 }</span></span><br><span class="line">square_set = { x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, -<span class="number">1</span>] }             <span class="comment"># { 1 }</span></span><br></pre></td></tr></table></figure><p>如果你不需要使用到列表中的元素，那么可以将下划线当作变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zeroes = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> even_numbers] <span class="comment"># 与列表 even_numbers 有相同的长度</span></span><br></pre></td></tr></table></figure><p>列表解析支持多重 <code>for</code> 循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(x, y)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]    <span class="comment"># 共100对： (0,0) (0,1) ... (9,8), (9,9)</span></span><br></pre></td></tr></table></figure><p>后面的 <code>for</code> 循环可以使用前面 f`or 循环的结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">increasing_pairs = [(x, y)                      <span class="comment"># 只包含 x &lt; y 的数据对</span></span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)          <span class="comment"># range(lo, hi) equals</span></span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(x + <span class="number">1</span>, <span class="number">10</span>)]  <span class="comment"># [lo, lo + 1, ..., hi - 1]</span></span><br></pre></td></tr></table></figure><p>未来我们将会经常用到列表解析。</p><h3 id="生成器和迭代器-Generators-and-Iterators"><a href="#生成器和迭代器-Generators-and-Iterators" class="headerlink" title="生成器和迭代器 Generators and Iterators"></a>生成器和迭代器 Generators and Iterators</h3><p>列表有一个问题就是一不小心就会变得非常庞大，比如 <code>range(1000000)</code> 将会生成一个具有一百万个元素的列表。如果一次只处理一个数据，耗时可能会过长（或内存耗尽）。而实际上你可能只用到前几个数据，这样其他运算就是多余的。</p><p>而生成器可以让你只迭代那些需要用到的数据。可以使用函数和 <code>yield</code> 表达式来创建一个生成器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_range</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""a lazy version of range"""</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>译者补充：<br>生成器也是一种特殊迭代器，<code>yield</code> 是生成器实现迭代的关键。它作为生成器执行的暂停恢复点，可以对 <code>yield</code> 表达式进行赋值，也可以将 <code>yield</code> 表达式的值返回。任何包含 <code>yield</code> 语句的函数被称为生成器。跳出生成器时，生成器将当前执行状态保存，并在下次执行时恢复现场，以获得下一个迭代值。采用列表迭代将会占用大量地址空间，而使用生成器差不多只占用一个地址空间，从而达到节约内存的效果。</p><p>下面这个循环将一次消耗一个 <code>yield</code> 中的值直到消耗完毕:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lazy_range(<span class="number">10</span>):</span><br><span class="line">    do_something_with(i)</span><br></pre></td></tr></table></figure><p>(事实上 Python 自带了一个实现如上 <code>_lazy_range_</code> 效果的函数，称为 <code>xrange</code>, Python 3 中称为 <code>lazy</code>.) 这意味着你可以创建一个无穷数列:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">natural_numbers</span>():</span><br><span class="line">    <span class="string">"""返回 1, 2, 3, ..."""</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>不过并不建议使用这种没有退出循环逻辑的语句。</p><p><strong>TIP</strong></p><blockquote><p>使用生成器迭代的一个缺点就是，从头到尾对元素只能迭代一次，如果想实现多次迭代，你只能每次都创建新的生成器或者使用列表。</p></blockquote><p>第二种创建生成器的方法：利用括号内的解析表达式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy_evens_below_20 = (i <span class="keyword">for</span> i <span class="keyword">in</span> lazy_range(<span class="number">20</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>我们知道字典中的 items() 方法将返回一列表的字典中全部的键值对，但更多情况下，我们使用 iteritems() 生成器方法来进行迭代，每次只产生并返回一个键值对。</p><h3 id="随机-Randomness"><a href="#随机-Randomness" class="headerlink" title="随机 Randomness"></a>随机 Randomness</h3><p>在学习数据科学的时候，我们将会经常需要生成随机数，所以只要导入 random 模块就能使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">four_uniform_randoms = [random.random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="comment"># [0.8444218515250481,        # random.random() 生成随机数</span></span><br><span class="line"><span class="comment"># 0.7579544029403025,         # 随机数被标准化处理，范围介于 0 和 1 之间</span></span><br><span class="line"><span class="comment"># 0.420571580830845,          # 该函数是最常用的用于生成随机数的函数</span></span><br><span class="line"><span class="comment"># 0.25891675029296335]</span></span><br></pre></td></tr></table></figure><p>如果你想获得可重现的结果，可以让 <code>random</code> 模块基于 <code>random.seed</code> 设置的内部状态生成伪随机（即确定性）数字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random.seed(<span class="number">10</span>)           <span class="comment"># set the seed to 10</span></span><br><span class="line"><span class="built_in">print</span> random.random()     <span class="comment"># 0.57140259469</span></span><br><span class="line">random.seed(<span class="number">10</span>)           <span class="comment"># reset the seed to 10</span></span><br><span class="line"><span class="built_in">print</span> random.random()     <span class="comment"># 0.57140259469 again</span></span><br></pre></td></tr></table></figure><p>有时候我们也会使用 <code>random.randrange</code> 函数来生成一个指定范围内的随机数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.randrange(<span class="number">10</span>)      <span class="comment"># 从 range(10) = [0, 1, ..., 9] 中随机选择一个数</span></span><br><span class="line">random.randrange(<span class="number">3</span>, <span class="number">6</span>)    <span class="comment"># 从 range(3, 6) = [3, 4, 5] 随机选择一个数</span></span><br></pre></td></tr></table></figure><p>还有一些方法有时候用起来很方便，比如 random.shuffle 将打乱一个列表中的元素次序，重新生成一个随机排列的列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">up_to_ten = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">random.shuffle(up_to_ten)</span><br><span class="line"><span class="built_in">print</span> up_to_ten</span><br><span class="line"><span class="comment"># [2, 5, 1, 9, 7, 3, 8, 6, 4, 0] (你得到的结果应该不同)</span></span><br></pre></td></tr></table></figure><p>如果想从一个列表中随机选择一个元素，可以使用 random.choice 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_best_friend = random.choice([<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>]) <span class="comment"># 我得到的是 "Bob"</span></span><br></pre></td></tr></table></figure><p>如果既想要生成一个随机序列，又不想打乱原列表，可以使用 <code>random.sample</code> 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lottery_numbers = <span class="built_in">range</span>(<span class="number">60</span>)</span><br><span class="line">winning_numbers = random.sample(lottery_numbers, <span class="number">6</span>) <span class="comment"># [16, 36, 10, 6, 25, 9]</span></span><br></pre></td></tr></table></figure><p>你可以通过多次调用实现多个随机样本的选择（允许重复）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">four_with_replacement = [random.choice(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">                         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="comment"># [9, 4, 4, 2]</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式-Regular-Expressions"><a href="#正则表达式-Regular-Expressions" class="headerlink" title="正则表达式 Regular Expressions"></a>正则表达式 Regular Expressions</h3><p>正则表达式用于文本搜索，略显复杂但非常有用，因而有大量的书专门讲解正则表达式。我们遇到它们的时候再进行具体的解释，下面是一些在 Python 中使用正则表达式的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">all</span>([                                 <span class="comment"># 下面的表述全部返回 true, 因为</span></span><br><span class="line">    <span class="keyword">not</span> re.<span class="keyword">match</span>(<span class="string">"a"</span>, <span class="string">"cat"</span>),               <span class="comment"># * 'cat' 不以 'a' 开头</span></span><br><span class="line">    re.search(<span class="string">"a"</span>, <span class="string">"cat"</span>),                  <span class="comment"># * 'cat' 中包含了字母 'a'</span></span><br><span class="line">    <span class="keyword">not</span> re.search(<span class="string">"c"</span>, <span class="string">"dog"</span>),              <span class="comment"># * 'dog' 中不包含字母 'c'</span></span><br><span class="line">    <span class="number">3</span> == <span class="built_in">len</span>(re.split(<span class="string">"[ab]"</span>, <span class="string">"carbs"</span>)),    <span class="comment"># * 根据 a 或 b 将单词拆分成三部分 ['c','r','s']</span></span><br><span class="line">    <span class="string">"R-D-"</span> == re.sub(<span class="string">"[0-9]"</span>, <span class="string">"-"</span>, <span class="string">"R2D2"</span>)  <span class="comment"># * 用短横替换数字</span></span><br><span class="line">    ])                                      <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure><h3 id="面向对象编程-Object-Oriented-Programming"><a href="#面向对象编程-Object-Oriented-Programming" class="headerlink" title="面向对象编程 Object-Oriented Programming"></a>面向对象编程 Object-Oriented Programming</h3><p>与许多语言一样，Python 允许你定义封装数据的类和对其进行操作的函数。我们有时会使用它们来使我们的代码更清晰简洁。通过构建一个带有大量注释的示例来解释它们可能是最简单的。假设没有内置的 Python 集合，我们可能想要创建自己的 <code>Set</code> 类。那么这个类应当具备哪些功能呢？比如给定一个 <code>Set</code> ，我们需要能够向其中添加项目，从中删除项目，并检查它是否包含特定值。所以，我们将创建所有这些功能将其作为该类的成员函数。这样，我们就可以在 <code>Set</code> 对象之后用点访问这些成员函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照惯例，我们给出 _PascalCase_ 类的名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:</span><br><span class="line">    <span class="comment"># 这些是成员函数</span></span><br><span class="line">    <span class="comment"># 每个成员函数都有一个置于首位的"self"参数(另一个惯例)</span></span><br><span class="line">    <span class="comment"># “self”对应于正在使用的特定的 Set 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, values=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">"""这是创建函数</span></span><br><span class="line"><span class="string">        每当你创建一个新的 Set 就会调用该函数</span></span><br><span class="line"><span class="string">        可以像这样调用</span></span><br><span class="line"><span class="string">        s1 = Set() # 空集合</span></span><br><span class="line"><span class="string">        s2 = Set([1,2,2,3]) # 根据指定值初始化集合"""</span></span><br><span class="line">        self.<span class="built_in">dict</span> = {} <span class="comment"># Set 中的每个实例都有自己的 dict 属性</span></span><br><span class="line">        <span class="comment"># 我们使用该属性追踪每个成员</span></span><br><span class="line">        <span class="keyword">if</span> values <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            self.add(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""这是 Set 对象中的字符串表达式</span></span><br><span class="line"><span class="string">        你可以通过向 Python 命令窗口键入字符串或者利用 str() 方法向对象传递字符串"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Set: "</span> + <span class="built_in">str</span>(self.<span class="built_in">dict</span>.keys())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们将通过成为 self.dict 中的键，并将键值设为 True 来表示成员资格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.<span class="built_in">dict</span>[value] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果参数为字典中的键，对应的值就在 Set 中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">in</span> self.<span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">dict</span>[value]</span><br></pre></td></tr></table></figure><p>然后我们就可以像这样使用 <code>Set</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="type">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span> s.contains(<span class="number">4</span>)     <span class="comment"># True</span></span><br><span class="line">s.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> s.contains(<span class="number">3</span>)     <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="函数工具-Functional-Tools"><a href="#函数工具-Functional-Tools" class="headerlink" title="函数工具 Functional Tools"></a>函数工具 Functional Tools</h3><h4 id="部分函数-partial"><a href="#部分函数-partial" class="headerlink" title="部分函数 partial"></a>部分函数 partial</h4><p>当传递函数时，有时我们会想要使用某函数的部分功能以创建新函数。举个简单的例子，假设我们有两个变量的函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">base, power</span>):</span><br><span class="line">    <span class="keyword">return</span> base ** power</span><br></pre></td></tr></table></figure><p>我们想要利用它来创建一个函数，该函数输入一个变量，输出底数为 2 的幂函数 <code>exp(2, power)</code> 的结果。</p><p>当然，我们可以用 <code>def</code> 定义一个新的函数，虽然这看起来不太明智:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_to_the</span>(<span class="params">power</span>):</span><br><span class="line">  <span class="keyword">return</span> exp(<span class="number">2</span>, power)</span><br></pre></td></tr></table></figure><p>更聪明的做法是利用 <code>functools.partial</code> 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">two_to_the = partial(exp, <span class="number">2</span>)      <span class="comment"># 当前函数只有一个变量</span></span><br><span class="line"><span class="built_in">print</span> two_to_the(<span class="number">3</span>)               <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><p>如果指定了名称，也可以使用 <code>partial</code> 方法填充其他的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square_of = partial(exp, power=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> square_of(<span class="number">3</span>)                <span class="comment"># 9</span></span><br></pre></td></tr></table></figure><p>如果你尝试在函数中间乱用参数，那么程序将很快就会变得混乱，所以请尽量避免这种行为。</p><h4 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h4><p>我们偶尔也会使用 <code>map</code>，<code>reduce</code>，和 <code>filter</code> 等函数来作为列表解析的功能替代:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line">xs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">twice_xs = [double(x) <span class="keyword">for</span> x <span class="keyword">in</span> xs]      <span class="comment"># [2, 4, 6, 8]</span></span><br><span class="line">twice_xs = <span class="built_in">map</span>(double, xs)              <span class="comment"># 同上</span></span><br><span class="line">list_doubler = partial(<span class="built_in">map</span>, double)     <span class="comment"># 函数功能是将列表加倍</span></span><br><span class="line">twice_xs = list_doubler(xs)             <span class="comment"># 也是 [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p><code>map</code> 方法还可以用于多参数函数到多列表的映射:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>): <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">products = <span class="built_in">map</span>(multiply, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># [1 * 4, 2 * 5] = [4, 10]</span></span><br></pre></td></tr></table></figure><h4 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h4><p>类似地，过滤器实现的是列表解析中 <code>if</code> 的功能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">"""若 x 为偶数则返回 True，x 为奇数则返回 False"""</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x_evens = [x <span class="keyword">for</span> x <span class="keyword">in</span> xs <span class="keyword">if</span> is_even(x)]   <span class="comment"># [2, 4]</span></span><br><span class="line">x_evens = <span class="built_in">filter</span>(is_even, xs)             <span class="comment"># 同上</span></span><br><span class="line">list_evener = partial(<span class="built_in">filter</span>, is_even)    <span class="comment"># 该函数实现过滤功能</span></span><br><span class="line">x_evens = list_evener(xs)                 <span class="comment"># 也是 [2, 4]</span></span><br></pre></td></tr></table></figure><h4 id="缩减-reduce"><a href="#缩减-reduce" class="headerlink" title="缩减 reduce"></a>缩减 reduce</h4><p><code>reduce</code> 方法不断合并列表中的第一个和第二个元素，然后将结果与第三个元素合并，并一直重复这个过程，直到得到一个唯一的结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_product = reduce(multiply, xs)          <span class="comment"># = 1 * 2 * 3 * 4 = 24</span></span><br><span class="line">list_product = partial(reduce, multiply)  <span class="comment"># 该函数实现缩减一个列表</span></span><br><span class="line">x_product = list_product(xs)              <span class="comment"># 也是 24</span></span><br></pre></td></tr></table></figure><h3 id="枚举-enumerate"><a href="#枚举-enumerate" class="headerlink" title="枚举 enumerate"></a>枚举 enumerate</h3><p>偶尔会出现这样的情况，在遍历一个列表的时候同时要使用元素和其索引:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不太 Python（不太简洁优美）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(documents)):</span><br><span class="line">    document = documents[i]</span><br><span class="line">    do_something(i, document)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样不太 Python（不太简洁优美）</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> document <span class="keyword">in</span> documents:</span><br><span class="line">    do_something(i, document)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最简洁的做法是使用 <code>enumerate</code> 枚举方法生成一个元组 <code>tuples (index, element)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, document <span class="keyword">in</span> <span class="built_in">enumerate</span>(documents):</span><br><span class="line">    do_something(i, document)</span><br></pre></td></tr></table></figure><p>类似地，如果只想使用索引:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(documents)): do_something(i)   <span class="comment"># 不简洁</span></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(documents): do_something(i) <span class="comment"># 简洁</span></span><br></pre></td></tr></table></figure><p>后面我们将会经常使用这个方法。</p><h3 id="压缩和参数解压-zip-and-Argument-Unpacking"><a href="#压缩和参数解压-zip-and-Argument-Unpacking" class="headerlink" title="压缩和参数解压 zip and Argument Unpacking"></a>压缩和参数解压 zip and Argument Unpacking</h3><h4 id="压缩-zip"><a href="#压缩-zip" class="headerlink" title="压缩 zip"></a>压缩 zip</h4><p>我们经常会对两个或更多的列表进行压缩处理。压缩实际上就是将多列表转化为对应元组的单列表形式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">zip</span>(list1, list2)       <span class="comment"># 得到 [('a', 1), ('b', 2), ('c', 3)]</span></span><br></pre></td></tr></table></figure><h4 id="参数解压-Argument-Unpacking"><a href="#参数解压-Argument-Unpacking" class="headerlink" title="参数解压 Argument Unpacking"></a>参数解压 Argument Unpacking</h4><p>如果多个列表长度不一致，那么压缩过程会在最短列表尾部停止。你也可以使用一个奇怪的 “unzip” 解压缩技巧对列表进行解压:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]</span><br><span class="line">letters, numbers = <span class="built_in">zip</span>(*pairs)</span><br></pre></td></tr></table></figure><p>其中星号用于执行参数解压缩，它使用 pairs 的元素作为 zip 的单个参数。下面的调用方式具有同等效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zip</span>((<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>))  <span class="comment"># 返回 [('a','b','c'), ('1','2','3')]</span></span><br></pre></td></tr></table></figure><p>参数解压也可以和其他函数共同使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>): <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment"># 返回 3</span></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>])         <span class="comment"># 报错</span></span><br><span class="line">add(*[<span class="number">1</span>, <span class="number">2</span>])        <span class="comment"># 返回 3</span></span><br></pre></td></tr></table></figure><p>虽然不太实用，不过是个不错的让代码变得简洁的技巧。</p><h3 id="不定长参数传递-args-and-kwargs"><a href="#不定长参数传递-args-and-kwargs" class="headerlink" title="不定长参数传递 args and kwargs"></a>不定长参数传递 args and kwargs</h3><p>假设我们要创建一个高阶函数，该函数输入一个旧函数，并返回一个新的函数，新函数是旧函数乘以 2 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doubler</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * f(x)</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>运行例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">g = doubler(f1)</span><br><span class="line"><span class="built_in">print</span> g(<span class="number">3</span>)        <span class="comment"># 8 (== ( 3 + 1) * 2)</span></span><br><span class="line"><span class="built_in">print</span> g(-<span class="number">1</span>)       <span class="comment"># 0 (== (-1 + 1) * 2)</span></span><br></pre></td></tr></table></figure><p>然而只要传递的参数大于一个，该方法就不太好用了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">g = doubler(f2)</span><br><span class="line"><span class="built_in">print</span> g(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 报错 TypeError: g() takes exactly 1 argument (2 given)</span></span><br></pre></td></tr></table></figure><p>所以我们需要指定一个函数，使得它能够容纳任意数量的参数，然后利用参数解压缩实现传递多个参数，这看起来有那么一点神奇:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"unnamed args:"</span>, args</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"keyword args:"</span>, kwargs</span><br><span class="line">magic(<span class="number">1</span>, <span class="number">2</span>, key=<span class="string">"word"</span>, key2=<span class="string">"word2"</span>)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># unnamed args: (1, 2)</span></span><br><span class="line"><span class="comment"># keyword args: {'key2': 'word2', 'key': 'word'}</span></span><br></pre></td></tr></table></figure><p>当我们像这样定义一个函数时，<code>args</code> (arguments 的缩写)是一个包含未命名参数的元组，而 <code>kwargs</code> (keyword arguments 的缩写)是包含命名参数的字典。</p><p>它们也可以用在传递的参数为列表（或元组）或数组的情况：<br>n:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">other_way_magic</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line"></span><br><span class="line">x_y_list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">z_dict = { <span class="string">"z"</span> : <span class="number">3</span> }</span><br><span class="line"><span class="built_in">print</span> other_way_magic(*x_y_list, **z_dict)    <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>你可以用它配合各种奇怪的方法使用，但我们只用它来解决高阶函数传递不定长参数的问题:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doubler_correct</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="string">"""不论 f 是什么都能有效运行"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="string">"""不论有多少参数，该函数都能正确将参数传递给 f"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line">g = doubler_correct(f2)</span><br><span class="line"><span class="built_in">print</span> g(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><h3 id="欢迎来到数据科学的世界！"><a href="#欢迎来到数据科学的世界！" class="headerlink" title="欢迎来到数据科学的世界！"></a>欢迎来到数据科学的世界！</h3><p>叮！恭喜你又打开了新世界的大门！接下来就可以去愉快地玩耍啦~</p><p><strong>相关阅读:</strong></p><p><a href="https://philoli.com/python-tutorails-basic-level">数据科学中常用的 Python 语法(基础)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天在看这本 &lt;a href=&quot;https://book.douban.com/subject/26364377/&quot;&gt;Data Science from Scrach&lt;/a&gt; (&lt;a href=&quot;http://www.zhanjunlang.com/resources/tutorial/Data%20Science%20from%20Scratch%20First%20Principles%20with%20Python.pdf&quot;&gt;PDF地址&lt;/a&gt; )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。&lt;br&gt;&lt;a href=&quot;https://philoli.com/python-tutorails-basic-level/&quot;&gt;数据科学中常用的 Python 语法(基础)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://philoli.com/python-tutorails-advanced-level/&quot;&gt;数据科学中常用的 Python 语法(进阶)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;本章侧重于介绍在数据处理中非常有用的 Python 进阶语法和功能（基于 Python 2.7 ）。&lt;/p&gt;</summary>
    
    
    
    <category term="数据科学" scheme="https://philo-li.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Python" scheme="https://philo-li.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据科学中 Python 的常用语法(基础)</title>
    <link href="https://philo-li.com/python-tutorails-basic-level/"/>
    <id>https://philo-li.com/python-tutorails-basic-level/</id>
    <published>2018-11-07T11:53:13.000Z</published>
    <updated>2024-04-13T05:30:53.732Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在看这本 <a href="https://book.douban.com/subject/26364377/">Data Science from Scrach</a> (<a href="http://www.zhanjunlang.com/resources/tutorial/Data%20Science%20from%20Scratch%20First%20Principles%20with%20Python.pdf">PDF地址</a> )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。<br><a href="https://lulalap.com/2018/11/07/python-tutorails-basic-level/">数据科学中常用的 Python 语法(基础)</a><br><a href="https://lulalap.com/2018/11/09/python-tutorails-advanced-level/">数据科学中常用的 Python 语法(进阶)</a>  </p><p>本章侧重于介绍在数据处理中非常有用的 Python 基础语法和功能（基于 Python 2.7 ）。</p><span id="more"></span><h3 id="空格格式"><a href="#空格格式" class="headerlink" title="空格格式"></a><a href="#%E7%A9%BA%E6%A0%BC%E6%A0%BC%E5%BC%8F" title="空格格式"></a>空格格式</h3><p>许多语言使用括号来控制代码块，但 Python 用的是缩进：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:  </span><br><span class="line">    <span class="built_in">print</span> i          <span class="comment"># "for i"循环的第一行  </span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:  </span><br><span class="line">        <span class="built_in">print</span> j      <span class="comment"># "for j"循环的第一行  </span></span><br><span class="line">        <span class="built_in">print</span> i + j  <span class="comment"># "for j"循环的最后一行  </span></span><br><span class="line">    <span class="built_in">print</span> i          <span class="comment"># "for i"循环的最后一行  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">"done looping"</span>  </span><br></pre></td></tr></table></figure><p>这使得 Python 的代码非常易于阅读，但也意味着你要时刻注意格式。括号里的空格将会被忽略，这在写长表达式时很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long_winded_computation = (<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> + <span class="number">10</span> + <span class="number">11</span> + <span class="number">12</span> + <span class="number">13</span> + <span class="number">14</span> + <span class="number">15</span> + <span class="number">16</span> + <span class="number">17</span> + <span class="number">18</span> + <span class="number">19</span> + <span class="number">20</span>)  </span><br></pre></td></tr></table></figure><p>也使得代码变得好读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_of_lists = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]  </span><br><span class="line">easier_to_read_list_of_lists = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  </span><br><span class="line">                                 [<span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span> ],  </span><br><span class="line">                                 [<span class="number">7</span> ,<span class="number">8</span> ,<span class="number">9</span> ] ]  </span><br></pre></td></tr></table></figure><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a><a href="#%E5%A4%9A%E8%A1%8C%E8%AF%AD%E5%8F%A5" title="多行语句"></a>多行语句</h3><p>可以用一个反斜杠来表示连接中断的两行（这种做法很少用）：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">two_plus_three = <span class="number">2</span> + \</span><br><span class="line">                 <span class="number">3</span>  </span><br></pre></td></tr></table></figure><h3 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a><a href="#%E6%A8%A1%E5%9D%97-Modules" title="模块 Modules"></a>模块 Modules</h3><p>不论是 Python 自带的模块还是自己下载的第三方的模块，都需要需要通过手动导入才能使用。</p><p>1.简单地直接导入整个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line">my_regex = re.<span class="built_in">compile</span>(<span class="string">"[0-9]+"</span>, re.I)  </span><br></pre></td></tr></table></figure><p>这里导入的 <code>_re_</code> 模块是用于正则表达式的。导入模块后，可以直接将模块名字作为前缀（re.）来调用具体功能。</p><p>2.如果调入的模块名称已经在代码中被使用，可以将模块导入时映射到另一个名称中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re <span class="keyword">as</span> regex  </span><br><span class="line">my_regex = regex.<span class="built_in">compile</span>(<span class="string">"[0-9]+"</span>, regex.I)  </span><br></pre></td></tr></table></figure><p>3.如果你很坏，你就可以将整个模块都导入到当前命名空间，这可能在不经意间覆盖你已经定义好的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> *  <span class="comment"># re 模块中有一个 match 函数  </span></span><br><span class="line"><span class="built_in">print</span> <span class="keyword">match</span>       <span class="comment"># 输出 match 函数  </span></span><br></pre></td></tr></table></figure><p>因为你是个好人，所以我相信你不会这么做的。</p><h3 id="四则运算-Arithmetic"><a href="#四则运算-Arithmetic" class="headerlink" title="四则运算 Arithmetic"></a><a href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97-Arithmetic" title="四则运算 Arithmetic"></a>四则运算 Arithmetic</h3><p>Python 2.7 默认使用整除，所以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.542ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3333.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1000,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(1777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>.但很多时候我们并不想要整除，所以可以导入这个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division  </span><br></pre></td></tr></table></figure><p>导入后，就有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.302ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4111.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1000,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(1777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g></g></g></svg></mjx-container>.<br>整除：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.673ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3833.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3333.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>.</p><h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a><a href="#%E5%87%BD%E6%95%B0-Functions" title="函数 Functions"></a>函数 Functions</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89" title="函数定义"></a>函数定义</h4><p>函数是能够接收 0 个或多个输入，并返回一定输出的一个规则。在 Python 中，我们用 <code>def 函数名(参数)</code> 定义一个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="string">"""你可以在这里写一些关于函数功能的解释  </span></span><br><span class="line"><span class="string">    比如，该函数将输入内容乘2"""</span>  </span><br><span class="line">    <span class="comment"># 这里可以写函数主体，记得缩进  </span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>  </span><br></pre></td></tr></table></figure><h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a><a href="#%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8" title="函数使用"></a>函数使用</h4><p>在 Python 中，函数是最低等级的存在，这意味着我们可以将函数赋值给一个变量，也可以将它作为一个参数传递给其他变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_one</span>(<span class="params">f</span>):  </span><br><span class="line">    <span class="string">"""调用函数 f 并将 1 作为函数参数"""</span>  </span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">1</span>)  </span><br><span class="line">my_double = double          <span class="comment"># double 指向上一节定义的函数  </span></span><br><span class="line">x = apply_to_one(my_double) <span class="comment"># x 等于 2  </span></span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" title="匿名函数"></a>匿名函数</h4><p>还可以通过 <code>lambda</code> 来创建匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = apply_to_one(<span class="keyword">lambda</span> x: x + <span class="number">4</span>)     <span class="comment"># 等于 5  </span></span><br></pre></td></tr></table></figure><p>可以将 <code>lambda</code> 赋值给其他变量，但大多数人会建议你还是尽量使用 <em>def</em> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">another_double = <span class="keyword">lambda</span> x: <span class="number">2</span> * x      <span class="comment"># 不建议  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_double</span>(<span class="params">x</span>): <span class="keyword">return</span> <span class="number">2</span> * x   <span class="comment"># 建议做法  </span></span><br></pre></td></tr></table></figure><p>补充：</p><ul><li><code>lambda</code> 只是一个表达式，函数体比 <code>def</code> 简单很多。</li><li><code>lambda</code> 的主体是一个表达式，而不是一个代码块。仅仅能在 <code>lambda</code> 表达式中封装有限的逻辑进去。</li></ul><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" title="函数参数传递"></a>函数参数传递</h4><p>函数参数可以定义默认值，函数表达式不加参数将使用默认值，加参数将传递指定值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_print</span>(<span class="params">message=<span class="string">"my default message"</span></span>):  </span><br><span class="line">    <span class="built_in">print</span> message  </span><br><span class="line">my_print(<span class="string">"hello"</span>)     <span class="comment"># 输出 "hello"  </span></span><br><span class="line">my_print()            <span class="comment"># 输出 "my default message"  </span></span><br></pre></td></tr></table></figure><p>有时候直接通过参数名称来指定参数也很好用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">a=<span class="number">0</span>, b=<span class="number">0</span></span>):  </span><br><span class="line">    <span class="keyword">return</span> a - b  </span><br><span class="line">subtract(<span class="number">10</span>, <span class="number">5</span>)   <span class="comment"># 返回 5  </span></span><br><span class="line">subtract(<span class="number">0</span>, <span class="number">5</span>)    <span class="comment"># 返回 -5  </span></span><br><span class="line">subtract(b=<span class="number">5</span>)     <span class="comment"># 与上一个相同，返回 -5  </span></span><br></pre></td></tr></table></figure><h3 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 Strings"></a><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-Strings" title="字符串 Strings"></a>字符串 Strings</h3><p>可以使用单引号或双引号来创建字符串（引号一定要配对）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single_quoted_string = <span class="string">'data science'</span>  </span><br><span class="line">double_quoted_string = <span class="string">"data science"</span>  </span><br></pre></td></tr></table></figure><p>用反斜杠来表示转义字符，如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab_string = <span class="string">"\t"</span>      <span class="comment"># 表示制表符 tab  </span></span><br><span class="line"><span class="built_in">len</span>(tab_string)        <span class="comment"># 等于 1  </span></span><br></pre></td></tr></table></figure><p>当你想要使用反斜杠本身 (用于 Windows 目录或者正则表达式), 可以通过使用原始字符串 <code>r""</code> 定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not_tab_string = <span class="string">r"\t"</span> <span class="comment"># 表示字符 '\' 和 't'  </span></span><br><span class="line"><span class="built_in">len</span>(not_tab_string)    <span class="comment"># 等于 2  </span></span><br></pre></td></tr></table></figure><p>利用三个双引号创建多行字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi_line_string = <span class="string">"""这是第一行  </span></span><br><span class="line"><span class="string">这是第二行  </span></span><br><span class="line"><span class="string">这是第三行"""</span>  </span><br></pre></td></tr></table></figure><h3 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理 Exception"></a><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-Exception" title="异常处理 Exception"></a>异常处理 Exception</h3><p>当程序出错，Python 会发生一个 <code>异常(exception)</code>，我们不对其进行处理的话，程序将会终止执行。捕获异常可以用 <code>try</code> 和 <code>except</code> 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="number">0</span> / <span class="number">0</span>  </span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">"不能除以0"</span>  </span><br></pre></td></tr></table></figure><p>尽管在其他语言中，异常被看作是不好的现象，但在 Python 中，多处理异常将会使你的代码更加简洁干净。</p><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a><a href="#%E5%88%97%E8%A1%A8-Lists" title="列表 Lists"></a>列表 Lists</h3><h4 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a><a href="#%E5%88%9B%E5%BB%BA%E5%88%97%E8%A1%A8" title="创建列表"></a>创建列表</h4><p>列表是简单的有序集合，也是 Python 中最基础的数据结构 (类似其他语言中的数组，但列表具有一些额外的特性)。创建一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">integer_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line">heterogeneous_list = [<span class="string">"string"</span>, <span class="number">0.1</span>, <span class="literal">True</span>]  </span><br><span class="line">list_of_lists = [ integer_list, heterogeneous_list, [] ]  </span><br><span class="line">list_length = <span class="built_in">len</span>(integer_list)   <span class="comment"># 等于 3  </span></span><br><span class="line">list_sum = <span class="built_in">sum</span>(integer_list)      <span class="comment"># 等于 6  </span></span><br></pre></td></tr></table></figure><h4 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a><a href="#%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%BC" title="访问列表中的值"></a>访问列表中的值</h4><p>你可以通过方括号索引列表中的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">range</span>(<span class="number">10</span>)       <span class="comment"># 列表获得列表 x = [0, 1, ..., 9]  </span></span><br><span class="line">zero = x[<span class="number">0</span>]         <span class="comment"># 等于 0, 列表序号从 0 开始  </span></span><br><span class="line">one = x[<span class="number">1</span>]          <span class="comment"># 等于 1  </span></span><br><span class="line">nine = x[-<span class="number">1</span>]        <span class="comment"># 等于 9, 列表中最后一个元素  </span></span><br><span class="line">eight = x[-<span class="number">2</span>]       <span class="comment"># 等于 8, 列表中倒数第二个元素  </span></span><br><span class="line">x[<span class="number">0</span>] = -<span class="number">1</span>           <span class="comment"># 当前列表 x = [-1, 1, 2, 3, ..., 9]  </span></span><br></pre></td></tr></table></figure><h4 id="截取列表"><a href="#截取列表" class="headerlink" title="截取列表"></a><a href="#%E6%88%AA%E5%8F%96%E5%88%97%E8%A1%A8" title="截取列表"></a>截取列表</h4><p>可以用方括号截取列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first_three = x[:<span class="number">3</span>]                  <span class="comment"># [-1, 1, 2]  </span></span><br><span class="line">three_to_end = x[<span class="number">3</span>:]                 <span class="comment"># [3, 4, ..., 9]  </span></span><br><span class="line">one_to_four = x[<span class="number">1</span>:<span class="number">5</span>]                 <span class="comment"># [1, 2, 3, 4]  </span></span><br><span class="line">last_three = x[-<span class="number">3</span>:]                  <span class="comment"># [7, 8, 9]  </span></span><br><span class="line">without_first_and_last = x[<span class="number">1</span>:-<span class="number">1</span>]     <span class="comment"># [1, 2, ..., 8]  </span></span><br><span class="line">copy_of_x = x[:]                     <span class="comment"># [-1, 1, 2, ..., 9]  </span></span><br></pre></td></tr></table></figure><p>可以用 <code>in</code> 来查看某元素是否在列表中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]        <span class="comment"># True  </span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]        <span class="comment"># False  </span></span><br></pre></td></tr></table></figure><p>这种元素查找方式效率很低，只有在列表很小或者你不在意查找时间的情况下再去使用。</p><h4 id="拼接列表"><a href="#拼接列表" class="headerlink" title="拼接列表"></a><a href="#%E6%8B%BC%E6%8E%A5%E5%88%97%E8%A1%A8" title="拼接列表"></a>拼接列表</h4><p>Python 中很容易就能拼接两个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line">x.extend([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])   <span class="comment"># 当前 x = [1,2,3,4,5,6]  </span></span><br></pre></td></tr></table></figure><p>如果你不想修改原列表 x ，你可以使用“加”运算符创建一个新的列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line">y = x + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]     <span class="comment"># 当前 y = [1, 2, 3, 4, 5, 6]; x 没有变化  </span></span><br></pre></td></tr></table></figure><p>经常用这样的方式一次在列表中添加一个元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line">x.append(<span class="number">0</span>)           <span class="comment"># 当前 x = [1, 2, 3, 0]  </span></span><br><span class="line">y = x[-<span class="number">1</span>]             <span class="comment"># 等于 0  </span></span><br><span class="line">z = <span class="built_in">len</span>(x)            <span class="comment"># 等于 4  </span></span><br></pre></td></tr></table></figure><h4 id="列表分解"><a href="#列表分解" class="headerlink" title="列表分解"></a><a href="#%E5%88%97%E8%A1%A8%E5%88%86%E8%A7%A3" title="列表分解"></a>列表分解</h4><p>如果你知道列表中有多少个元素，那么很容易就能分解这个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = [<span class="number">1</span>, <span class="number">2</span>]         <span class="comment"># 当前 x = 1, y = 2  </span></span><br></pre></td></tr></table></figure><p>等式两边元素数目不一致的话，你将会得到一个 _值错误_，所以我们更经常用下划线来存放列表剩下的部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, y = [<span class="number">1</span>, <span class="number">2</span>]         <span class="comment"># 当前 y == 2, 不管第一个元素  </span></span><br></pre></td></tr></table></figure><h3 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组 Tuples"></a><a href="#%E5%85%83%E7%BB%84-Tuples" title="元组 Tuples"></a>元组 Tuples</h3><p>列表和元组很像，和列表唯一的区别就是，元组中的元素不能被修改。</p><h4 id="元组创建"><a href="#元组创建" class="headerlink" title="元组创建"></a><a href="#%E5%85%83%E7%BB%84%E5%88%9B%E5%BB%BA" title="元组创建"></a>元组创建</h4><p>可以使用圆括号或者不加任何括号来创建元组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line">other_tuple = <span class="number">3</span>, <span class="number">4</span>  </span><br><span class="line">my_list[<span class="number">1</span>] = <span class="number">3</span>        <span class="comment"># 当前 my_list 为 [1, 3]  </span></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    my_tuple[<span class="number">1</span>] = <span class="number">3</span>  </span><br><span class="line"><span class="keyword">except</span> TypeError:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">"无法修改元组"</span>  </span><br></pre></td></tr></table></figure><p>利用元组能够很方便地从函数中获取多个返回值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_and_product</span>(<span class="params">x, y</span>):  </span><br><span class="line">    <span class="keyword">return</span> (x + y),(x * y)  </span><br><span class="line">sp = sum_and_product(<span class="number">2</span>, <span class="number">3</span>)    <span class="comment"># 等于 (5, 6)  </span></span><br><span class="line">s, p = sum_and_product(<span class="number">5</span>, <span class="number">10</span>) <span class="comment"># s = 15, p = 50  </span></span><br></pre></td></tr></table></figure><p>元组（和列表）都支持同时赋值多个元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span>       <span class="comment"># 当前 x = 1, y = 2  </span></span><br><span class="line">x, y = y, x       <span class="comment"># Python 中交换两个变量的值; 当前 x = 2, y = 1  </span></span><br></pre></td></tr></table></figure><h3 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典 Dictionaries"></a><a href="#%E5%AD%97%E5%85%B8-Dictionaries" title="字典 Dictionaries"></a>字典 Dictionaries</h3><h4 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a><a href="#%E5%AD%97%E5%85%B8%E5%88%9B%E5%BB%BA" title="字典创建"></a>字典创建</h4><p>Python 中的另一个基础数据结构是字典，它能让你通过关键字（key）快速获得对应的值（value）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">empty_dict = {}                       <span class="comment"># 非常 Python 化的空字典定义  </span></span><br><span class="line">empty_dict2 = <span class="built_in">dict</span>()                  <span class="comment"># 没那么 Python 化的空字典定义  </span></span><br><span class="line">grades = { <span class="string">"Joel"</span> : <span class="number">80</span>, <span class="string">"Tim"</span> : <span class="number">95</span> }  <span class="comment"># 字典存储  </span></span><br></pre></td></tr></table></figure><h4 id="字典元素查找"><a href="#字典元素查找" class="headerlink" title="字典元素查找"></a><a href="#%E5%AD%97%E5%85%B8%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE" title="字典元素查找"></a>字典元素查找</h4><p>你可以用方括号加关键字来查找对应的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joels_grade = grades[<span class="string">"Joel"</span>]          <span class="comment"># 等于 80  </span></span><br></pre></td></tr></table></figure><p>如果要查找的关键字不在字典中，将返回一个 <code>键错误(KeyError)</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    kates_grade = grades[<span class="string">"Kate"</span>]  </span><br><span class="line"><span class="keyword">except</span> KeyError:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">"no grade for Kate!"</span>  </span><br></pre></td></tr></table></figure><p>可以通过 <code>in</code> 来查看关键字是否在字典中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joel_has_grade = <span class="string">"Joel"</span> <span class="keyword">in</span> grades     <span class="comment"># True  </span></span><br><span class="line">kate_has_grade = <span class="string">"Kate"</span> <span class="keyword">in</span> grades     <span class="comment"># False  </span></span><br></pre></td></tr></table></figure><p>字典有一个可以返回默认值的方法，当要查找的关键字不在字典中将会返回设定的默认值（而不是发生异常）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">joels_grade = grades.get(<span class="string">"Joel"</span>, <span class="number">0</span>)   <span class="comment"># 等于 80  </span></span><br><span class="line">kates_grade = grades.get(<span class="string">"Kate"</span>, <span class="number">0</span>)   <span class="comment"># 等于 0  </span></span><br><span class="line">no_ones_grade = grades.get(<span class="string">"No One"</span>)  <span class="comment"># 返回默认值 None  </span></span><br></pre></td></tr></table></figure><h4 id="字典修改"><a href="#字典修改" class="headerlink" title="字典修改"></a><a href="#%E5%AD%97%E5%85%B8%E4%BF%AE%E6%94%B9" title="字典修改"></a>字典修改</h4><p>可以用方括号来创建、修改字典中的键值对:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grades[<span class="string">"Tim"</span>] = <span class="number">99</span>                    <span class="comment"># 替换旧的值  </span></span><br><span class="line">grades[<span class="string">"Kate"</span>] = <span class="number">100</span>                  <span class="comment"># 增加一个键值对  </span></span><br><span class="line">num_students = <span class="built_in">len</span>(grades)            <span class="comment"># 等于 3  </span></span><br></pre></td></tr></table></figure><p>我们将会经常像这样使用字典来表达数据的结构:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tweet = {  </span><br><span class="line">    <span class="string">"user"</span> : <span class="string">"joelgrus"</span>,  </span><br><span class="line">    <span class="string">"text"</span> : <span class="string">"Data Science is Awesome"</span>,  </span><br><span class="line">    <span class="string">"retweet_count"</span> : <span class="number">100</span>,  </span><br><span class="line">    <span class="string">"hashtags"</span> : [<span class="string">"#data"</span>, <span class="string">"#science"</span>, <span class="string">"#datascience"</span>, <span class="string">"#awesome"</span>, <span class="string">"#yolo"</span>]  </span><br><span class="line">}  </span><br></pre></td></tr></table></figure><p>除了查找特定关键字，我们还可以像这样操作所有关键字:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tweet_keys = tweet.keys()             <span class="comment"># 得到一个关键字（键）列表  </span></span><br><span class="line">tweet_values = tweet.values()         <span class="comment"># 得到值列表  </span></span><br><span class="line">tweet_items = tweet.items()           <span class="comment"># 得到 (键, 值) 元组  </span></span><br><span class="line"><span class="string">"user"</span> <span class="keyword">in</span> tweet_keys                  <span class="comment"># 返回 True, 用的是列表效率较低中的 in 查找  </span></span><br><span class="line"><span class="string">"user"</span> <span class="keyword">in</span> tweet                       <span class="comment"># 更 Python 的用法, 用的是高效的字典中的 in 查找  </span></span><br><span class="line"><span class="string">"joelgrus"</span> <span class="keyword">in</span> tweet_values            <span class="comment"># True  </span></span><br></pre></td></tr></table></figure><p>字典中的键是唯一的，而且列表不能用作字典的关键字（键）。如果你需要一个多部分的关键字，你可以使用元组，或者通过某种途径将关键字转换成字符串。</p><h4 id="内置字典"><a href="#内置字典" class="headerlink" title="内置字典"></a><a href="#%E5%86%85%E7%BD%AE%E5%AD%97%E5%85%B8" title="内置字典"></a>内置字典</h4><p>如果你正试图统计一个文档中每个词出现的频率，一个显然的做法是创建一个字典，词作为关键字，频率作为对应的值。然后遍历文档，遇到出现过的词就让字典对应键值自增 1 ，遇到未出现过的词就在字典中添加一个键值对:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word_counts = {}  </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> document:  </span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> word_counts:  </span><br><span class="line">        word_counts[word] += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        word_counts[word] = <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>当然，你也可以像这样用“先斩后奏”的方式来提前处理一个缺失的键:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word_counts = {}  </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> document:  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        word_counts[word] += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">except</span> KeyError:  </span><br><span class="line">        word_counts[word] = <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>第三个方法是使用 <code>get</code> ，这个方法对于缺失键的处理表现优异:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_counts = {}  </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> document:  </span><br><span class="line">    previous_count = word_counts.get(word, <span class="number">0</span>)  </span><br><span class="line">    word_counts[word] = previous_count + <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>内置字典就跟普通字典一样，唯一的区别就是，当你试图在字典中查找一个不存在的键时，内置字典将利用你提供的关键字自动创建一个键值对。为了使用内置字典，你需要导入 <code>collections</code> 函数库:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </span><br><span class="line">word_counts = defaultdict(<span class="built_in">int</span>)        <span class="comment"># int() 生成 0  </span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> document:  </span><br><span class="line">    word_counts[word] += <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>在列表、普通字典甚至自定义的函数中，默认字典也都很好用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dd_list = defaultdict(<span class="built_in">list</span>)           <span class="comment"># list() 生成一个空列表  </span></span><br><span class="line">dd_list[<span class="number">2</span>].append(<span class="number">1</span>)                  <span class="comment"># 当前 dd_list 为 {2: [1]}  </span></span><br><span class="line">dd_dict = defaultdict(<span class="built_in">dict</span>)           <span class="comment"># dict() 生成一个空字典  </span></span><br><span class="line">dd_dict[<span class="string">"Joel"</span>][<span class="string">"City"</span>] = <span class="string">"Seattle"</span>   <span class="comment"># 当前 dd_dict 内容为 { "Joel" : { "City" : Seattle"}}  </span></span><br><span class="line">dd_pair = defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 创建了一个关键字对于的值为列表的字典  </span></span><br><span class="line">dd_pair[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>                     <span class="comment"># 当前 dd_pair 内容为 {2: [0,1]}  </span></span><br></pre></td></tr></table></figure><p>这种方法很有用，以后我们要获取字典中的某些键值结果时，就无需再检查键是否存在了。</p><h3 id="计数器-Counter"><a href="#计数器-Counter" class="headerlink" title="计数器 Counter"></a><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8-Counter" title="计数器 Counter"></a>计数器 Counter</h3><p>计数器可以直接将一组值转换成类似字典的对象，关键字为这组中的某个元素，对应的值为该元素出现的次数。这在创建直方图的时候会经常用到:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter  </span><br><span class="line">c = Counter([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]) <span class="comment"># c (差不多)为 { 0 : 2, 1 : 1, 2 : 1 }  </span></span><br></pre></td></tr></table></figure><p>这样我们就有了一个很方便的统计词频的方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word_counts = Counter(document)  </span><br></pre></td></tr></table></figure><p>计数器还有一个很常用的方法 <code>most_common</code>，可以直接得到最高频的几个词和对应的频率:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出前 10 个最高频的词以及他们的计数值  </span></span><br><span class="line"><span class="keyword">for</span> word, count <span class="keyword">in</span> word_counts.most_common(<span class="number">10</span>):  </span><br><span class="line">    <span class="built_in">print</span> word, count  </span><br></pre></td></tr></table></figure><h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合 Sets"></a><a href="#%E9%9B%86%E5%90%88-Sets" title="集合 Sets"></a>集合 Sets</h3><p>Python 中另一种数据结构是集合，集合是一组不同元素的收集。<br>可以这样创建一个集合并向其中添加元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()  </span><br><span class="line">s.add(<span class="number">1</span>)          <span class="comment"># s 为 { 1 }  </span></span><br><span class="line">s.add(<span class="number">2</span>)          <span class="comment"># s 为 { 1, 2 }  </span></span><br><span class="line">s.add(<span class="number">2</span>)          <span class="comment"># s 为 { 1, 2 }  </span></span><br><span class="line">x = <span class="built_in">len</span>(s)        <span class="comment"># 等于 2  </span></span><br><span class="line">y = <span class="number">2</span> <span class="keyword">in</span> s        <span class="comment"># 等于 True  </span></span><br><span class="line">z = <span class="number">3</span> <span class="keyword">in</span> s        <span class="comment"># 等于 False  </span></span><br></pre></td></tr></table></figure><p>使用集合的两大理由：</p><p>第一，集合中的 <code>in</code> 操作非常高效。当一个数据集中的元素数量非常庞大的时候，以集合的形式来查找元素显然比列表更加合适:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stopwords_list = [<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"at"</span>] + hundreds_of_other_words + [<span class="string">"yet"</span>, <span class="string">"you"</span>]  </span><br><span class="line"><span class="string">"zip"</span> <span class="keyword">in</span> stopwords_list               <span class="comment"># 失败，需要去检查每个元素  </span></span><br><span class="line">stopwords_set = <span class="built_in">set</span>(stopwords_list)  </span><br><span class="line"><span class="string">"zip"</span> <span class="keyword">in</span> stopwords_set                <span class="comment"># 查找成功，而且速度很快  </span></span><br></pre></td></tr></table></figure><p>第二，用集合来获取一组数据中不同的元素非常方便:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line">num_items = <span class="built_in">len</span>(item_list)            <span class="comment"># 6  </span></span><br><span class="line">item_set = <span class="built_in">set</span>(item_list)             <span class="comment"># {1, 2, 3}  </span></span><br><span class="line">num_distinct_items = <span class="built_in">len</span>(item_set)    <span class="comment"># 3  </span></span><br><span class="line">distinct_item_list = <span class="built_in">list</span>(item_set)   <span class="comment"># [1, 2, 3]  </span></span><br></pre></td></tr></table></figure><p>不过实际上，集合的使用频率还是没有字典和列表高。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a><a href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5" title="条件语句"></a>条件语句</h3><p>在绝大多数编程语言中，你都可以像这样用 <em>if</em> 来表示条件分支:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">2</span>:  </span><br><span class="line">    message = <span class="string">"if only 1 were greater than two…"</span>  </span><br><span class="line"><span class="keyword">elif</span> <span class="number">1</span> &gt; <span class="number">3</span>:  </span><br><span class="line">    message = <span class="string">"elif stands for 'else if'"</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    message = <span class="string">"when all else fails use else (if you want to)"</span>  </span><br></pre></td></tr></table></figure><p>你也可以像这样将条件分支语句写在一行中，但这很少用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parity = <span class="string">"even"</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">"odd"</span>  </span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5" title="循环语句"></a>循环语句</h3><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><a href="#while-%E5%BE%AA%E7%8E%AF" title="while 循环"></a><em>while</em> 循环</h4><p>Python 中的 <code>while</code> 循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">10</span>:  </span><br><span class="line">    <span class="built_in">print</span> x, <span class="string">"is less than 10"</span>  </span><br><span class="line">    x += <span class="number">1</span>  </span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><a href="#for-%E5%BE%AA%E7%8E%AF" title="for 循环"></a><em>for</em> 循环</h4><p>更常用的是使用 <code>for-in</code> 循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  </span><br><span class="line">    <span class="built_in">print</span> x, <span class="string">"is less than 10"</span>  </span><br></pre></td></tr></table></figure><p>更复杂的逻辑表达式可以使用 <code>continue</code> 和 <code>break</code> 语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  </span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">3</span>:  </span><br><span class="line">        <span class="keyword">continue</span>          <span class="comment"># 直接进入下一轮循环  </span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">5</span>:  </span><br><span class="line">        <span class="keyword">break</span>             <span class="comment"># 完全退出循环  </span></span><br><span class="line">    <span class="built_in">print</span> x  </span><br></pre></td></tr></table></figure><p>结果将会输出 0， 1， 2，和 4。</p><h3 id="真值-Truthiness"><a href="#真值-Truthiness" class="headerlink" title="真值 Truthiness"></a><a href="#%E7%9C%9F%E5%80%BC-Truthiness" title="真值 Truthiness"></a>真值 Truthiness</h3><p>Python 中的布尔变量 <code>Booleans</code> 用法和其他语言差不多，唯一的区别是首字母一定要大写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one_is_less_than_two = <span class="number">1</span> &lt; <span class="number">2</span>      <span class="comment"># 为 True  </span></span><br><span class="line">true_equals_false = <span class="literal">True</span> == <span class="literal">False</span> <span class="comment"># 为 False  </span></span><br></pre></td></tr></table></figure><p>Python 使用 <code>None</code> 来表示一个值不存在，类似其他语言中的 <code>null</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">None</span>  </span><br><span class="line"><span class="built_in">print</span> x == <span class="literal">None</span>        <span class="comment"># 输出 True, 不够优美  </span></span><br><span class="line"><span class="built_in">print</span> x <span class="keyword">is</span> <span class="literal">None</span>        <span class="comment"># 输出 True, 更优美  </span></span><br></pre></td></tr></table></figure><p>Python 允许你用其他值代替布尔值，以下皆等价于 <code>False</code>:</p><ul><li>False</li><li>None</li><li>[] (一个空列表)</li><li>{} (一个空字典)</li><li>“”</li><li>set()</li><li>0</li><li>0.0</li></ul><p>类似的也有很多 <code>True</code> 的等价值，这让你非常方便地判断空列表、空字符串以及空字典等等。</p><p>当然，如果你不能预见结果的话，可能会在使用过程中出错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = some_function_that_returns_a_string()  </span><br><span class="line"><span class="keyword">if</span> s:  </span><br><span class="line">    first_char = s[<span class="number">0</span>]  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    first_char = <span class="string">""</span>  </span><br></pre></td></tr></table></figure><p>一个更简单的做法，该做法效果等同于上面的做法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_char = s <span class="keyword">and</span> s[<span class="number">0</span>]  </span><br></pre></td></tr></table></figure><p>如果第一个值为真，将返回第二个值，否则返回第一个值。</p><p>类似地，如果 x 可能是一个数字也可能为空，那么这样可以得到一个肯定为数字的 x :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safe_x = x <span class="keyword">or</span> <span class="number">0</span>  </span><br></pre></td></tr></table></figure><p>Python 中还有一个 <code>all</code> 函数，在每个元素都为 <code>True</code> 时函数返回 <code>True</code>。<code>any</code> 函数，只要有一个元素为 <code>True</code> 就返回 <code>True</code>。比如对于一个每一个元素都为“真”的列表，<code>all</code> 函数将返回<code>True</code>，否则将返回<code>False</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all</span>([<span class="literal">True</span>, <span class="number">1</span>, { <span class="number">3</span> }])       <span class="comment"># True  </span></span><br><span class="line"><span class="built_in">all</span>([<span class="literal">True</span>, <span class="number">1</span>, {}])          <span class="comment"># False, {} 等价于“False”  </span></span><br><span class="line"><span class="built_in">any</span>([<span class="literal">True</span>, <span class="number">1</span>, {}])          <span class="comment"># True  </span></span><br><span class="line"><span class="built_in">all</span>([])                     <span class="comment"># True, 不存在一个等价于“False”的元素  </span></span><br><span class="line"><span class="built_in">any</span>([])                     <span class="comment"># False, 不存在一个等价于“True”的元素  </span></span><br></pre></td></tr></table></figure><p><strong>进阶阅读:</strong><br><a href="https://philoli.com/python-tutorails-advanced-level/">数据科学中常用的 Python 语法(进阶)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天在看这本 &lt;a href=&quot;https://book.douban.com/subject/26364377/&quot;&gt;Data Science from Scrach&lt;/a&gt; (&lt;a href=&quot;http://www.zhanjunlang.com/resources/tutorial/Data%20Science%20from%20Scratch%20First%20Principles%20with%20Python.pdf&quot;&gt;PDF地址&lt;/a&gt; )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。&lt;br&gt;&lt;a href=&quot;https://lulalap.com/2018/11/07/python-tutorails-basic-level/&quot;&gt;数据科学中常用的 Python 语法(基础)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://lulalap.com/2018/11/09/python-tutorails-advanced-level/&quot;&gt;数据科学中常用的 Python 语法(进阶)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;本章侧重于介绍在数据处理中非常有用的 Python 基础语法和功能（基于 Python 2.7 ）。&lt;/p&gt;</summary>
    
    
    
    <category term="数据科学" scheme="https://philo-li.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="Python" scheme="https://philo-li.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>我居然错过了考研正式报名</title>
    <link href="https://philo-li.com/I-Missed-A-Important-Test/"/>
    <id>https://philo-li.com/I-Missed-A-Important-Test/</id>
    <published>2018-11-05T11:53:13.000Z</published>
    <updated>2024-04-13T03:44:10.674Z</updated>
    
    <content type="html"><![CDATA[<p>预想过失败的很多种方式，但没想到的是，有一天我会栽到这里。</p><p>但更令我惊讶的还是，我居然一点也不难过，反而还有点开心。</p><span id="more"></span><p>这是真正自由的味道，在逃离大学这个牢笼之后。</p><h2 id="一战浙大计算机"><a href="#一战浙大计算机" class="headerlink" title="一战浙大计算机"></a>一战浙大计算机</h2><p>去年这时候，我刚刚结束长达两个月的平均每天 5 公里的长跑计划。这是一次试图探索自己极限的尝试。</p><p>这之前以及这之后的半个多月，每天还是悠然自得地学上 6 - 7 个小时，然后跑步，或者摸鱼。这期间我每天还能有精力构思考研百日倒计时的创意形式，每日更新，画在在寝室里的白板上。</p><p>还剩 40 多天的时候，开始感到时间不够用了，专业课只过了一遍，个别章节甚至完全没有看；线代才做一半，概率论还没开始看，真题也还没开始做。政治才做过一遍 1000 题，大题没怎么看。</p><p>还剩一个月的时候，这辈子考试都没慌过的我终于开始慌了。我知道自己无论如何也没有时间做第二遍了。</p><p>还有三周的时候，大脑一片空白，似乎复习过的痕迹丝毫没有留下记忆，打算放弃的想法划过脑海。</p><p>经过一番思索后，还是决定挣扎一下。</p><p>极端紧迫的时间条件和糟糕的复习状况，成为了一个触发条件，像是正好打破了那道壁垒，进入了 zoom 状态，作为一名自我诊断为 ADD 的人士，我第一次体验到什么叫真正的专注。</p><h3 id="最后当然是毫无悬念地失败了"><a href="#最后当然是毫无悬念地失败了" class="headerlink" title="最后当然是毫无悬念地失败了"></a>最后当然是毫无悬念地失败了</h3><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><strong>数学一</strong></p><p>数学一全书完整的一遍都没做完，最后遇上数一这一年爆冷近几年最难，我把能写上的都写上了。<br>目标：随缘</p><p>结果：数学一 90 &#x2F; 150 分。</p><p><strong>政治</strong></p><p>政治大题花了四个晚上一个下午背的肖四，用理解记忆 或者 拆字记忆法 40 个字记忆几百字答案，大概背了七八题。考试时，答案都出现在题干的情况下，3 小时没停笔。<br>目标：65<br>结果：政治 70 &#x2F; 100 分。</p><p><strong>英语一</strong></p><p>英语真题阅读做了两遍，核心单词背了忘，忘了还忘。考试做阅读时差点睡着。作文背了模板，结果在考场上放飞了自我开始随心所欲自由发挥。<br>目标：70<br>结果：英语一 68 &#x2F; 100 分。</p><p><strong>专业课</strong></p><p>专业课，数据结构算法完全没有复习，组成原理两个大章节没有复习，王道只做过一遍。考试 15 分的算法题扣光。<br>目标：随缘<br>结果：408专业课 106 &#x2F; 150 分。</p><p>总分：334<br>复试线：361<br>该专业报名人数：约2000</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>最后当然是毫无悬念地失败了。自我分析一下原因。</p><p><strong>客观原因：</strong></p><ul><li>浙大计算机报名人数爆炸<ul><li>前年报名人数 1200+，复试线 330+；去年报名人数2000，复试线361，总体试卷难度高于上一年。</li></ul></li><li>零基础跨专业跨学校跨地区<ul><li>俗称难度最大的三跨考生</li></ul></li></ul><p><strong>主观原因：</strong></p><ul><li>我菜</li><li>我懒</li><li>我每天只看不到 7 小时的书</li><li>我只复习了一遍还没看完</li></ul><p>事无巨细地述说去年考试的细节，除了单纯回顾一下我还想说什么：</p><h3 id="研究生并不难考"><a href="#研究生并不难考" class="headerlink" title="研究生并不难考"></a>研究生并不难考</h3><ul><li>我如此糟糕的复习状况，最后结果也没有太难看，说明研究生考试难度并不是很大。只要不是跨专业不考TOP2，其他学校基本是很容易上的，身边有不少案例。</li><li>跨考的只要不是考热门专业，没有上千的报名人数，基本上也是很好考的。（一般专业有超过 500 人报考就算很多了）</li><li>跨考的又是热门专业，只要你比我再上点心，别天天摸鱼，我想问题也不会很大。</li><li>上岸的也没必要天天吹到处秀优越感</li></ul><h2 id="决定二战"><a href="#决定二战" class="headerlink" title="决定二战"></a>决定二战</h2><p>毕竟是跨考，毕竟是零基础学计算机的四大专业课，毕竟整个复习过程太悠闲，所以再给点时间，二战一定没有问题的吧，我这样告诉自己。</p><p>正式复习依然是 7 月份开始。依然是悠闲的复习，但这次是脚踏实地的悠闲复习。<br>此处省略 x 字。</p><h2 id="突然得知已经错过了正式报名"><a href="#突然得知已经错过了正式报名" class="headerlink" title="突然得知已经错过了正式报名"></a>突然得知已经错过了正式报名</h2><p>第一反应是惊讶。我也不知道为什么，今年没有像去年那样设置日历事件提醒。总之在几分钟后接受了没办法挽回的事实后，一边和朋友报告这个消息，一边重新思考自己到底为什么要考研。</p><p>主要是两大原因，如今分别对其进行反驳：</p><blockquote><p>1.方便转行<br>读研可以让我快速进入一个全新的领域。</p></blockquote><p><strong>反驳：</strong></p><ul><li><strong>计算机互联网行业转行太容易了</strong><ul><li>有人上了几个月培训班就能去写代码了；有人读完硕博想转行计算机，就自学几个月相关领域知识代码技能，去谷歌上班了</li><li>如果只是单纯为了转行，没有必要花费三年时间去读研</li></ul></li></ul><blockquote><p>2.提升学历<br>拥有一个 985 的硕士文凭总是好的，也能证明实力。</p></blockquote><p><strong>反驳：</strong></p><ul><li><strong>我并没有很强烈的名校情结</strong><ul><li>我不崇拜权威。在国内的应试教育的环境之下，很多人对学霸有着天然的好感，自然而然地有一种崇敬之情。但我觉得这是狼奶，得吐，说白了这还是潜意识里一种对于权威的崇拜。</li><li>那为什么非得是浙大？因为浙大计算机是国内顶尖的，同时浙大复试是出了名的公平公开，而且校风学风自由开放。</li><li>其他人我无所谓，最想向父母证明自己的实力，想告诉他们我并不比别人差。但证明实力并不是只有这一种方式。</li></ul></li><li><strong>我不一定喜欢做计算机相关的研究</strong><ul><li>计算机领域的研究无非是阅读最新论文、相关书籍，听讲座，做实验（电脑上），写论文。</li><li>但是我喜欢计算机的一点是，它是一种万能的工具，一种你可以操作的工具。你可以切实可行地用它来做一点什么事情，即便只是很微小的一个部分，但可以改变你自己的或者别人的生活。</li></ul></li><li><strong>考上了也不能自由选择研究方向</strong><ul><li>研究方向还需要经过实验室面试才能确定，热门实验室热门导师总是很抢手，很有可能最后去的实验室并不是自己感兴趣的领域。</li></ul></li><li><strong>不当研究生也没有人拦着你关注行业最新领域</strong><ul><li>计算机不像其他学科需要购置很多庞大的专业的实验器材，也没有严苛的实验条件，只要你有一台能上网的电脑，就能做很多事情。</li><li>网络上没有行业的资源能超越计算机的，铺天盖地的学习资料，开放的制作精良的网络课程，无数优秀的开源项目的源代码。最新研究论文随便阅读，你一样可以在自己电脑上重新实现论文中的想法，并运用到自己的工作当中。</li></ul></li><li><strong>一张硕士文凭和三年工作经验孰轻孰重</strong><ul><li>计算机行业知识和技术日新月异，研究生学的东西在工作中基本用不到，一切依然是从头开始</li><li>研究生文凭 + 无工作经验 vs 本科文凭 + 三年工作经验，实际上后者在薪资上更有竞争力</li></ul></li><li><strong>研究生是一个新的框</strong><ul><li>研究生有论文压力，同样有 Deadline，一样是被推着往前走</li><li>研究生导师一般都被称为“老板”，和工作一样，实际上也是替你的“老板”打工</li><li>刚刚从大学这个牢笼逃离出来，为什么要这么快进入一个新的框呢</li><li>什么时候读研都不会太迟</li></ul></li></ul><p>想通之后，一阵轻松。</p><p>当晚一夜无眠。想到可以继续看 kindle 中堆积了几个月的书，可以好好折腾自己的博客，可以去摄影，可以将最近的项目灵感付诸实践，可以把过去收藏了好久的计算机相关的博客文章拿出来好好研究，内心的喜悦随之一点点绽放开来。</p><p>嗯，是自由的味道，真正意义上的自由。</p><h2 id="自由与快乐"><a href="#自由与快乐" class="headerlink" title="自由与快乐"></a>自由与快乐</h2><p>我所追求的事物总结起来其实只有两点：1.自由，2.快乐。并且将这两点作为我是否要做某件事的衡量标准。</p><p>当初学物理，因为觉得物理能够让我更好地理解自己所生活的世界，了解世间万物为何如此运作。物理，因而名为“万物之理”。这是思想上的自由。</p><p>现在学计算机，因为觉得计算机是一种万能的工具，可以和任意领域结合，并且可以用来做出一些真正的、有用的“东西”，是能够做出可以让自己和他人感到便利，真切改善生活品质的工具。互联网是世界之窗，能够看到更大的世界。这是“行动”上的自由。</p><p>自由和快乐是相辅相成、相生相灭的。对我而言，失去自由的快乐不叫快乐，而失去快乐的自由是根本不存在的。</p><p>说来也奇怪，曾经好几次都是这样，虽然平日里也常常与阴郁和黑暗为伴，但在人生关键节点，脑海中描绘的未来永远是光明灿烂的。大概我真的自带“乐观的基因”吧。</p><p>觉得遗憾吗？有一点吧，毕竟现在总体第一轮复习差不多结束，数学一轮半并且真题已经能稳定在 130+ ；一年没碰政治，刚开始写 1000 题，选择题平均 100 个错 30 个，错的那些主要是完全需要死记硬背的没有任何逻辑性可言的生搬硬套部分；8 月份刷完了 PAT 算法题库；此时距离考试还有 50 天。</p><p>这些时间都浪费了吗？并没有，因为我很反感耗费时间在学习（自认为）毫无用处的事物上。我实际花费时间精力复习的部分或多或少都将在未来的学习工作中使用到：高数、线代、概率论都是数据科学和机器学习的理论基础，刷的算法题是工作日常要用的，四大专业课学完了这部分基础也达到了计算机专业本科生的水平，其他实在没用的东西比如政治根本没开始看。而且期间我利用闲暇时间做兼职，还挣了九千买了个相机，不亏。</p><p>当然你也可以认为，以上都是我失败的自我安慰。那又如何呢，你怎么想跟我有什么关系呢，我照样过得很好。</p><p>刚刚看到<a href="https://www.jiqizhixin.com/articles/2018-10-11-4">一篇文章</a>，文末有这样一句话感觉说得很好：</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>对自己好一点。你没有在 18 岁毕业又不会死，没有在二十几岁获得博士学位又怎么了，没有在多少岁成为百万富翁又会怎样。去发现这个世界，去了解自己，去享受生命的过程。</p>            <i class="fa fa-quote-right"></i>          </blockquote><p>你根本不知道明天会发生什么，我也想象不到有一天我会错过一个大型考试。</p><p>这一天，我看了一篇关于自然语言处理的综述，看教程学习爬虫爬了百科词条，翻出博客重新写博文，总之打开电脑就不想玩手机了。</p><p>原来总觉得人生苦短，但此时此刻，第一次觉得人生很长，我才 22 周岁，依然有大好时光。</p><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>塞翁失马，焉知非福。</p>            <i class="fa fa-quote-right"></i>          </blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;预想过失败的很多种方式，但没想到的是，有一天我会栽到这里。&lt;/p&gt;
&lt;p&gt;但更令我惊讶的还是，我居然一点也不难过，反而还有点开心。&lt;/p&gt;</summary>
    
    
    
    <category term="日常闲聊" scheme="https://philo-li.com/categories/%E6%97%A5%E5%B8%B8%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://philo-li.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>

<!doctypehtml><html lang=en><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 7.1.1" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link href=/lib/font-awesome/css/all.min.css rel=stylesheet><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"philo-li.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};</script><meta content="这两天在看这本 Data Science from Scrach (PDF地址 )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。数据科学中常用的 Python 语法(基础)数据科学中常用的 Python 语法(进阶)   本章侧重于介绍在数据处理中非常有用的 Pytho" name=description><meta content=article property=og:type><meta content="数据科学中 Python 的常用语法(进阶)" property=og:title><meta content=https://philo-li.com/python-tutorails-advanced-level/index.html property=og:url><meta content=未知的世界 property=og:site_name><meta content="这两天在看这本 Data Science from Scrach (PDF地址 )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。数据科学中常用的 Python 语法(基础)数据科学中常用的 Python 语法(进阶)   本章侧重于介绍在数据处理中非常有用的 Pytho" property=og:description><meta content=en_US property=og:locale><meta content=2018-11-07T14:53:13.000Z property=article:published_time><meta content=2024-04-13T05:17:19.064Z property=article:modified_time><meta content="Philo Li" property=article:author><meta content=Python property=article:tag><meta content=summary name=twitter:card><link href=https://philo-li.com/python-tutorails-advanced-level/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };</script><title>数据科学中 Python 的常用语法(进阶) | 未知的世界</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}</style><body itemscope itemtype=http://schema.org/WebPage><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label="Toggle navigation bar" class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>未知的世界</h1> <span class=logo-line-after><i></i></span> </a><p class=site-subtitle itemprop=description>The Unknown World</div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>Home</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>About</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>Tags</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>Categories</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>Archives</a></ul></nav></div></header><div class=back-to-top><i class="fa fa-arrow-up"></i><span>0%</span></div><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=en><link href=https://philo-li.com/python-tutorails-advanced-level/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/uploads/avatar.jpg itemprop=image> <meta content="Philo Li" itemprop=name> <meta content="Do something cool" itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=未知的世界 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>数据科学中 Python 的常用语法(进阶)</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>Posted on</span> <time itemprop="dateCreated datePublished" title="Created: 2018-11-07 23:53:13" datetime=2018-11-07T23:53:13+09:00>2018-11-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>Edited on</span> <time title="Modified: 2024-04-13 14:17:19" datetime=2024-04-13T14:17:19+09:00 itemprop=dateModified>2024-04-13</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>In</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/ itemprop=url rel=index><span itemprop=name>数据科学</span></a> </span> </span><br><span title="Symbols count in article" class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>Symbols count in article: </span> <span>3.7k</span> </span><span title="Reading time" class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>Reading time ≈</span> <span>14 mins.</span> </span></div></header><div class=post-body itemprop=articleBody><p>这两天在看这本 <a href=https://book.douban.com/subject/26364377/ rel=noopener target=_blank>Data Science from Scrach</a> (<a href=http://www.zhanjunlang.com/resources/tutorial/Data%20Science%20from%20Scratch%20First%20Principles%20with%20Python.pdf rel=noopener target=_blank>PDF地址</a> )，是本不错的通俗易懂的数据科学入门书籍。其中一个章节介绍了一下 Python 的基础语法和数据科学常用的进阶语法，觉得介绍得不错，很简洁明了，所以将其翻译一下放在这里以作备忘。<br><a href=https://philoli.com/python-tutorails-basic-level/ rel=noopener target=_blank>数据科学中常用的 Python 语法(基础)</a><br><a href=https://philoli.com/python-tutorails-advanced-level/ rel=noopener target=_blank>数据科学中常用的 Python 语法(进阶)</a><p>本章侧重于介绍在数据处理中非常有用的 Python 进阶语法和功能（基于 Python 2.7 ）。</p><span id=more></span><h3 id=排序-Sorting><a title="排序 Sorting" class=headerlink href=#排序-Sorting></a>排序 Sorting</h3><p>如果你想对 Python 的列表进行排序，可以使用列表的 <code>sort</code> 方法。如果你不想破坏原列表，可以使用 <code>sorted</code> 函数返回一个新的排好序的列表:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>x = [<span class=number>4</span>,<span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>]</span><br><span class=line>y = <span class=built_in>sorted</span>(x)       <span class=comment># y = [1,2,3,4], x 不变</span></span><br><span class=line>x.sort()            <span class=comment># 当前 x = [1,2,3,4]</span></span><br><span class=line>sort 或 <span class=built_in>sorted</span> 是默认从小到大对列表进行排序的。</span><br></pre></table></figure><p>如果想让它从大到小排序，可以指定一个 <code>reverse = True</code> 的参数。<p>也可以自定义排序函数，让列表按照指定关键字进行排序:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 按照绝对值从大到小排序</span></span><br><span class=line>x = <span class=built_in>sorted</span>([-<span class=number>4</span>,<span class=number>1</span>,-<span class=number>2</span>,<span class=number>3</span>], key=<span class=built_in>abs</span>, reverse=<span class=literal>True</span>) <span class=comment># is [-4,3,-2,1]</span></span><br><span class=line><span class=comment># 按照单词出现的次数从大到小进行排序</span></span><br><span class=line>wc = <span class=built_in>sorted</span>(word_counts.items(),</span><br><span class=line>key=<span class=keyword>lambda</span> (word, count): count,</span><br><span class=line>reverse=<span class=literal>True</span>)</span><br></pre></table></figure><h3 id=列表解析-List-Comprehensions><a title="列表解析 List Comprehensions" class=headerlink href=#列表解析-List-Comprehensions></a>列表解析 List Comprehensions</h3><p>我们会经常遇到这样的情况，想要提取列表中特定几个元素组成新的列表，或是改变其中几个元素的值，或者皆有。Python 中的惯用做法就是 列表解析（List Comprehensions） :<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>even_numbers = [x <span class=keyword>for</span> x <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>) <span class=keyword>if</span> x % <span class=number>2</span> == <span class=number>0</span>]  <span class=comment># [0, 2, 4]</span></span><br><span class=line>squares = [x * x <span class=keyword>for</span> x <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>)]                 <span class=comment># [0, 1, 4, 9, 16]</span></span><br><span class=line>even_squares = [x * x <span class=keyword>for</span> x <span class=keyword>in</span> even_numbers]        <span class=comment># [0, 4, 16]</span></span><br></pre></table></figure><p>类似地你可以将列表变成字典或集合:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>square_dict = { x : x * x <span class=keyword>for</span> x <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>) }       <span class=comment># { 0:0, 1:1, 2:4, 3:9, 4:16 }</span></span><br><span class=line>square_set = { x * x <span class=keyword>for</span> x <span class=keyword>in</span> [<span class=number>1</span>, -<span class=number>1</span>] }             <span class=comment># { 1 }</span></span><br></pre></table></figure><p>如果你不需要使用到列表中的元素，那么可以将下划线当作变量:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>zeroes = [<span class=number>0</span> <span class=keyword>for</span> _ <span class=keyword>in</span> even_numbers] <span class=comment># 与列表 even_numbers 有相同的长度</span></span><br></pre></table></figure><p>列表解析支持多重 <code>for</code> 循环:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>pairs = [(x, y)</span><br><span class=line>    <span class=keyword>for</span> x <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)</span><br><span class=line>    <span class=keyword>for</span> y <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)]    <span class=comment># 共100对： (0,0) (0,1) ... (9,8), (9,9)</span></span><br></pre></table></figure><p>后面的 <code>for</code> 循环可以使用前面 f`or 循环的结果:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>increasing_pairs = [(x, y)                      <span class=comment># 只包含 x < y 的数据对</span></span><br><span class=line>                    <span class=keyword>for</span> x <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)          <span class=comment># range(lo, hi) equals</span></span><br><span class=line>                    <span class=keyword>for</span> y <span class=keyword>in</span> <span class=built_in>range</span>(x + <span class=number>1</span>, <span class=number>10</span>)]  <span class=comment># [lo, lo + 1, ..., hi - 1]</span></span><br></pre></table></figure><p>未来我们将会经常用到列表解析。<h3 id=生成器和迭代器-Generators-and-Iterators><a title="生成器和迭代器 Generators and Iterators" class=headerlink href=#生成器和迭代器-Generators-and-Iterators></a>生成器和迭代器 Generators and Iterators</h3><p>列表有一个问题就是一不小心就会变得非常庞大，比如 <code>range(1000000)</code> 将会生成一个具有一百万个元素的列表。如果一次只处理一个数据，耗时可能会过长（或内存耗尽）。而实际上你可能只用到前几个数据，这样其他运算就是多余的。<p>而生成器可以让你只迭代那些需要用到的数据。可以使用函数和 <code>yield</code> 表达式来创建一个生成器:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">lazy_range</span>(<span class=params>n</span>):</span><br><span class=line>    <span class=string>"""a lazy version of range"""</span></span><br><span class=line>    i = <span class=number>0</span></span><br><span class=line>    <span class=keyword>while</span> i < n:</span><br><span class=line>        <span class=keyword>yield</span> i</span><br><span class=line>        i += <span class=number>1</span></span><br></pre></table></figure><p>译者补充：<br>生成器也是一种特殊迭代器，<code>yield</code> 是生成器实现迭代的关键。它作为生成器执行的暂停恢复点，可以对 <code>yield</code> 表达式进行赋值，也可以将 <code>yield</code> 表达式的值返回。任何包含 <code>yield</code> 语句的函数被称为生成器。跳出生成器时，生成器将当前执行状态保存，并在下次执行时恢复现场，以获得下一个迭代值。采用列表迭代将会占用大量地址空间，而使用生成器差不多只占用一个地址空间，从而达到节约内存的效果。<p>下面这个循环将一次消耗一个 <code>yield</code> 中的值直到消耗完毕:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> i <span class=keyword>in</span> lazy_range(<span class=number>10</span>):</span><br><span class=line>    do_something_with(i)</span><br></pre></table></figure><p>(事实上 Python 自带了一个实现如上 <code>_lazy_range_</code> 效果的函数，称为 <code>xrange</code>, Python 3 中称为 <code>lazy</code>.) 这意味着你可以创建一个无穷数列:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">natural_numbers</span>():</span><br><span class=line>    <span class=string>"""返回 1, 2, 3, ..."""</span></span><br><span class=line>    n = <span class=number>1</span></span><br><span class=line>    <span class=keyword>while</span> <span class=literal>True</span>:</span><br><span class=line>        <span class=keyword>yield</span> n</span><br><span class=line>        n += <span class=number>1</span></span><br></pre></table></figure><p>不过并不建议使用这种没有退出循环逻辑的语句。<p><strong>TIP</strong><blockquote><p>使用生成器迭代的一个缺点就是，从头到尾对元素只能迭代一次，如果想实现多次迭代，你只能每次都创建新的生成器或者使用列表。</blockquote><p>第二种创建生成器的方法：利用括号内的解析表达式:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>lazy_evens_below_20 = (i <span class=keyword>for</span> i <span class=keyword>in</span> lazy_range(<span class=number>20</span>) <span class=keyword>if</span> i % <span class=number>2</span> == <span class=number>0</span>)</span><br></pre></table></figure><p>我们知道字典中的 items() 方法将返回一列表的字典中全部的键值对，但更多情况下，我们使用 iteritems() 生成器方法来进行迭代，每次只产生并返回一个键值对。<h3 id=随机-Randomness><a title="随机 Randomness" class=headerlink href=#随机-Randomness></a>随机 Randomness</h3><p>在学习数据科学的时候，我们将会经常需要生成随机数，所以只要导入 random 模块就能使用:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> random</span><br><span class=line>four_uniform_randoms = [random.random() <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>4</span>)]</span><br><span class=line><span class=comment># [0.8444218515250481,        # random.random() 生成随机数</span></span><br><span class=line><span class=comment># 0.7579544029403025,         # 随机数被标准化处理，范围介于 0 和 1 之间</span></span><br><span class=line><span class=comment># 0.420571580830845,          # 该函数是最常用的用于生成随机数的函数</span></span><br><span class=line><span class=comment># 0.25891675029296335]</span></span><br></pre></table></figure><p>如果你想获得可重现的结果，可以让 <code>random</code> 模块基于 <code>random.seed</code> 设置的内部状态生成伪随机（即确定性）数字:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>random.seed(<span class=number>10</span>)           <span class=comment># set the seed to 10</span></span><br><span class=line><span class=built_in>print</span> random.random()     <span class=comment># 0.57140259469</span></span><br><span class=line>random.seed(<span class=number>10</span>)           <span class=comment># reset the seed to 10</span></span><br><span class=line><span class=built_in>print</span> random.random()     <span class=comment># 0.57140259469 again</span></span><br></pre></table></figure><p>有时候我们也会使用 <code>random.randrange</code> 函数来生成一个指定范围内的随机数:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>random.randrange(<span class=number>10</span>)      <span class=comment># 从 range(10) = [0, 1, ..., 9] 中随机选择一个数</span></span><br><span class=line>random.randrange(<span class=number>3</span>, <span class=number>6</span>)    <span class=comment># 从 range(3, 6) = [3, 4, 5] 随机选择一个数</span></span><br></pre></table></figure><p>还有一些方法有时候用起来很方便，比如 random.shuffle 将打乱一个列表中的元素次序，重新生成一个随机排列的列表:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>up_to_ten = <span class=built_in>range</span>(<span class=number>10</span>)</span><br><span class=line>random.shuffle(up_to_ten)</span><br><span class=line><span class=built_in>print</span> up_to_ten</span><br><span class=line><span class=comment># [2, 5, 1, 9, 7, 3, 8, 6, 4, 0] (你得到的结果应该不同)</span></span><br></pre></table></figure><p>如果想从一个列表中随机选择一个元素，可以使用 random.choice 方法:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>my_best_friend = random.choice([<span class=string>"Alice"</span>, <span class=string>"Bob"</span>, <span class=string>"Charlie"</span>]) <span class=comment># 我得到的是 "Bob"</span></span><br></pre></table></figure><p>如果既想要生成一个随机序列，又不想打乱原列表，可以使用 <code>random.sample</code> 方法:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>lottery_numbers = <span class=built_in>range</span>(<span class=number>60</span>)</span><br><span class=line>winning_numbers = random.sample(lottery_numbers, <span class=number>6</span>) <span class=comment># [16, 36, 10, 6, 25, 9]</span></span><br></pre></table></figure><p>你可以通过多次调用实现多个随机样本的选择（允许重复）:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>four_with_replacement = [random.choice(<span class=built_in>range</span>(<span class=number>10</span>))</span><br><span class=line>                         <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>4</span>)]</span><br><span class=line><span class=comment># [9, 4, 4, 2]</span></span><br></pre></table></figure><h3 id=正则表达式-Regular-Expressions><a title="正则表达式 Regular Expressions" class=headerlink href=#正则表达式-Regular-Expressions></a>正则表达式 Regular Expressions</h3><p>正则表达式用于文本搜索，略显复杂但非常有用，因而有大量的书专门讲解正则表达式。我们遇到它们的时候再进行具体的解释，下面是一些在 Python 中使用正则表达式的例子:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> re</span><br><span class=line><span class=built_in>print</span> <span class=built_in>all</span>([                                 <span class=comment># 下面的表述全部返回 true, 因为</span></span><br><span class=line>    <span class=keyword>not</span> re.<span class=keyword>match</span>(<span class=string>"a"</span>, <span class=string>"cat"</span>),               <span class=comment># * 'cat' 不以 'a' 开头</span></span><br><span class=line>    re.search(<span class=string>"a"</span>, <span class=string>"cat"</span>),                  <span class=comment># * 'cat' 中包含了字母 'a'</span></span><br><span class=line>    <span class=keyword>not</span> re.search(<span class=string>"c"</span>, <span class=string>"dog"</span>),              <span class=comment># * 'dog' 中不包含字母 'c'</span></span><br><span class=line>    <span class=number>3</span> == <span class=built_in>len</span>(re.split(<span class=string>"[ab]"</span>, <span class=string>"carbs"</span>)),    <span class=comment># * 根据 a 或 b 将单词拆分成三部分 ['c','r','s']</span></span><br><span class=line>    <span class=string>"R-D-"</span> == re.sub(<span class=string>"[0-9]"</span>, <span class=string>"-"</span>, <span class=string>"R2D2"</span>)  <span class=comment># * 用短横替换数字</span></span><br><span class=line>    ])                                      <span class=comment># 输出 True</span></span><br></pre></table></figure><h3 id=面向对象编程-Object-Oriented-Programming><a title="面向对象编程 Object-Oriented Programming" class=headerlink href=#面向对象编程-Object-Oriented-Programming></a>面向对象编程 Object-Oriented Programming</h3><p>与许多语言一样，Python 允许你定义封装数据的类和对其进行操作的函数。我们有时会使用它们来使我们的代码更清晰简洁。通过构建一个带有大量注释的示例来解释它们可能是最简单的。假设没有内置的 Python 集合，我们可能想要创建自己的 <code>Set</code> 类。那么这个类应当具备哪些功能呢？比如给定一个 <code>Set</code> ，我们需要能够向其中添加项目，从中删除项目，并检查它是否包含特定值。所以，我们将创建所有这些功能将其作为该类的成员函数。这样，我们就可以在 <code>Set</code> 对象之后用点访问这些成员函数:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=comment># 按照惯例，我们给出 _PascalCase_ 类的名称</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Set</span>:</span><br><span class=line>    <span class=comment># 这些是成员函数</span></span><br><span class=line>    <span class=comment># 每个成员函数都有一个置于首位的"self"参数(另一个惯例)</span></span><br><span class=line>    <span class=comment># “self”对应于正在使用的特定的 Set 对象</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">__init__</span>(<span class=params>self, values=<span class=literal>None</span></span>):</span><br><span class=line>        <span class=string>"""这是创建函数</span></span><br><span class=line><span class=string>        每当你创建一个新的 Set 就会调用该函数</span></span><br><span class=line><span class=string>        可以像这样调用</span></span><br><span class=line><span class=string>        s1 = Set() # 空集合</span></span><br><span class=line><span class=string>        s2 = Set([1,2,2,3]) # 根据指定值初始化集合"""</span></span><br><span class=line>        self.<span class=built_in>dict</span> = {} <span class=comment># Set 中的每个实例都有自己的 dict 属性</span></span><br><span class=line>        <span class=comment># 我们使用该属性追踪每个成员</span></span><br><span class=line>        <span class=keyword>if</span> values <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span>:</span><br><span class=line>            <span class=keyword>for</span> value <span class=keyword>in</span> values:</span><br><span class=line>            self.add(value)</span><br><span class=line></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">__repr__</span>(<span class=params>self</span>):</span><br><span class=line>        <span class=string>"""这是 Set 对象中的字符串表达式</span></span><br><span class=line><span class=string>        你可以通过向 Python 命令窗口键入字符串或者利用 str() 方法向对象传递字符串"""</span></span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Set: "</span> + <span class=built_in>str</span>(self.<span class=built_in>dict</span>.keys())</span><br><span class=line></span><br><span class=line>    <span class=comment># 我们将通过成为 self.dict 中的键，并将键值设为 True 来表示成员资格</span></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">add</span>(<span class=params>self, value</span>):</span><br><span class=line>        self.<span class=built_in>dict</span>[value] = <span class=literal>True</span></span><br><span class=line></span><br><span class=line>    <span class=comment># 如果参数为字典中的键，对应的值就在 Set 中</span></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">contains</span>(<span class=params>self, value</span>):</span><br><span class=line>        <span class=keyword>return</span> value <span class=keyword>in</span> self.<span class=built_in>dict</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">remove</span>(<span class=params>self, value</span>):</span><br><span class=line>        <span class=keyword>del</span> self.<span class=built_in>dict</span>[value]</span><br></pre></table></figure><p>然后我们就可以像这样使用 <code>Set</code>:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>s = <span class=type>Set</span>([<span class=number>1</span>,<span class=number>2</span>,<span class=number>3</span>])</span><br><span class=line>s.add(<span class=number>4</span>)</span><br><span class=line><span class=built_in>print</span> s.contains(<span class=number>4</span>)     <span class=comment># True</span></span><br><span class=line>s.remove(<span class=number>3</span>)</span><br><span class=line><span class=built_in>print</span> s.contains(<span class=number>3</span>)     <span class=comment># False</span></span><br></pre></table></figure><h3 id=函数工具-Functional-Tools><a title="函数工具 Functional Tools" class=headerlink href=#函数工具-Functional-Tools></a>函数工具 Functional Tools</h3><h4 id=部分函数-partial><a title="部分函数 partial" class=headerlink href=#部分函数-partial></a>部分函数 partial</h4><p>当传递函数时，有时我们会想要使用某函数的部分功能以创建新函数。举个简单的例子，假设我们有两个变量的函数:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">exp</span>(<span class=params>base, power</span>):</span><br><span class=line>    <span class=keyword>return</span> base ** power</span><br></pre></table></figure><p>我们想要利用它来创建一个函数，该函数输入一个变量，输出底数为 2 的幂函数 <code>exp(2, power)</code> 的结果。<p>当然，我们可以用 <code>def</code> 定义一个新的函数，虽然这看起来不太明智:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">two_to_the</span>(<span class=params>power</span>):</span><br><span class=line>  <span class=keyword>return</span> exp(<span class=number>2</span>, power)</span><br></pre></table></figure><p>更聪明的做法是利用 <code>functools.partial</code> 方法:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> functools <span class=keyword>import</span> partial</span><br><span class=line>two_to_the = partial(exp, <span class=number>2</span>)      <span class=comment># 当前函数只有一个变量</span></span><br><span class=line><span class=built_in>print</span> two_to_the(<span class=number>3</span>)               <span class=comment># 8</span></span><br></pre></table></figure><p>如果指定了名称，也可以使用 <code>partial</code> 方法填充其他的参数:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>square_of = partial(exp, power=<span class=number>2</span>)</span><br><span class=line><span class=built_in>print</span> square_of(<span class=number>3</span>)                <span class=comment># 9</span></span><br></pre></table></figure><p>如果你尝试在函数中间乱用参数，那么程序将很快就会变得混乱，所以请尽量避免这种行为。<h4 id=映射-map><a title="映射 map" class=headerlink href=#映射-map></a>映射 map</h4><p>我们偶尔也会使用 <code>map</code>，<code>reduce</code>，和 <code>filter</code> 等函数来作为列表解析的功能替代:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">double</span>(<span class=params>x</span>):</span><br><span class=line>    <span class=keyword>return</span> <span class=number>2</span> * x</span><br><span class=line></span><br><span class=line>xs = [<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>]</span><br><span class=line>twice_xs = [double(x) <span class=keyword>for</span> x <span class=keyword>in</span> xs]      <span class=comment># [2, 4, 6, 8]</span></span><br><span class=line>twice_xs = <span class=built_in>map</span>(double, xs)              <span class=comment># 同上</span></span><br><span class=line>list_doubler = partial(<span class=built_in>map</span>, double)     <span class=comment># 函数功能是将列表加倍</span></span><br><span class=line>twice_xs = list_doubler(xs)             <span class=comment># 也是 [2, 4, 6, 8]</span></span><br></pre></table></figure><p><code>map</code> 方法还可以用于多参数函数到多列表的映射:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">multiply</span>(<span class=params>x, y</span>): <span class=keyword>return</span> x * y</span><br><span class=line></span><br><span class=line>products = <span class=built_in>map</span>(multiply, [<span class=number>1</span>, <span class=number>2</span>], [<span class=number>4</span>, <span class=number>5</span>])  <span class=comment># [1 * 4, 2 * 5] = [4, 10]</span></span><br></pre></table></figure><h4 id=过滤器-filter><a title="过滤器 filter" class=headerlink href=#过滤器-filter></a>过滤器 filter</h4><p>类似地，过滤器实现的是列表解析中 <code>if</code> 的功能:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">is_even</span>(<span class=params>x</span>):</span><br><span class=line>    <span class=string>"""若 x 为偶数则返回 True，x 为奇数则返回 False"""</span></span><br><span class=line>    <span class=keyword>return</span> x % <span class=number>2</span> == <span class=number>0</span></span><br><span class=line></span><br><span class=line>x_evens = [x <span class=keyword>for</span> x <span class=keyword>in</span> xs <span class=keyword>if</span> is_even(x)]   <span class=comment># [2, 4]</span></span><br><span class=line>x_evens = <span class=built_in>filter</span>(is_even, xs)             <span class=comment># 同上</span></span><br><span class=line>list_evener = partial(<span class=built_in>filter</span>, is_even)    <span class=comment># 该函数实现过滤功能</span></span><br><span class=line>x_evens = list_evener(xs)                 <span class=comment># 也是 [2, 4]</span></span><br></pre></table></figure><h4 id=缩减-reduce><a title="缩减 reduce" class=headerlink href=#缩减-reduce></a>缩减 reduce</h4><p><code>reduce</code> 方法不断合并列表中的第一个和第二个元素，然后将结果与第三个元素合并，并一直重复这个过程，直到得到一个唯一的结果:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>x_product = reduce(multiply, xs)          <span class=comment># = 1 * 2 * 3 * 4 = 24</span></span><br><span class=line>list_product = partial(reduce, multiply)  <span class=comment># 该函数实现缩减一个列表</span></span><br><span class=line>x_product = list_product(xs)              <span class=comment># 也是 24</span></span><br></pre></table></figure><h3 id=枚举-enumerate><a title="枚举 enumerate" class=headerlink href=#枚举-enumerate></a>枚举 enumerate</h3><p>偶尔会出现这样的情况，在遍历一个列表的时候同时要使用元素和其索引:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment># 不太 Python（不太简洁优美）</span></span><br><span class=line><span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=built_in>len</span>(documents)):</span><br><span class=line>    document = documents[i]</span><br><span class=line>    do_something(i, document)</span><br><span class=line></span><br><span class=line><span class=comment># 同样不太 Python（不太简洁优美）</span></span><br><span class=line>i = <span class=number>0</span></span><br><span class=line><span class=keyword>for</span> document <span class=keyword>in</span> documents:</span><br><span class=line>    do_something(i, document)</span><br><span class=line>    i += <span class=number>1</span></span><br></pre></table></figure><p>最简洁的做法是使用 <code>enumerate</code> 枚举方法生成一个元组 <code>tuples (index, element)</code>:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> i, document <span class=keyword>in</span> <span class=built_in>enumerate</span>(documents):</span><br><span class=line>    do_something(i, document)</span><br></pre></table></figure><p>类似地，如果只想使用索引:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=built_in>len</span>(documents)): do_something(i)   <span class=comment># 不简洁</span></span><br><span class=line><span class=keyword>for</span> i, _ <span class=keyword>in</span> <span class=built_in>enumerate</span>(documents): do_something(i) <span class=comment># 简洁</span></span><br></pre></table></figure><p>后面我们将会经常使用这个方法。<h3 id=压缩和参数解压-zip-and-Argument-Unpacking><a title="压缩和参数解压 zip and Argument Unpacking" class=headerlink href=#压缩和参数解压-zip-and-Argument-Unpacking></a>压缩和参数解压 zip and Argument Unpacking</h3><h4 id=压缩-zip><a title="压缩 zip" class=headerlink href=#压缩-zip></a>压缩 zip</h4><p>我们经常会对两个或更多的列表进行压缩处理。压缩实际上就是将多列表转化为对应元组的单列表形式:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>list1 = [<span class=string>'a'</span>, <span class=string>'b'</span>, <span class=string>'c'</span>]</span><br><span class=line>list2 = [<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>]</span><br><span class=line><span class=built_in>zip</span>(list1, list2)       <span class=comment># 得到 [('a', 1), ('b', 2), ('c', 3)]</span></span><br></pre></table></figure><h4 id=参数解压-Argument-Unpacking><a title="参数解压 Argument Unpacking" class=headerlink href=#参数解压-Argument-Unpacking></a>参数解压 Argument Unpacking</h4><p>如果多个列表长度不一致，那么压缩过程会在最短列表尾部停止。你也可以使用一个奇怪的 “unzip” 解压缩技巧对列表进行解压:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>pairs = [(<span class=string>'a'</span>, <span class=number>1</span>), (<span class=string>'b'</span>, <span class=number>2</span>), (<span class=string>'c'</span>, <span class=number>3</span>)]</span><br><span class=line>letters, numbers = <span class=built_in>zip</span>(*pairs)</span><br></pre></table></figure><p>其中星号用于执行参数解压缩，它使用 pairs 的元素作为 zip 的单个参数。下面的调用方式具有同等效果:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>zip</span>((<span class=string>'a'</span>, <span class=number>1</span>), (<span class=string>'b'</span>, <span class=number>2</span>), (<span class=string>'c'</span>, <span class=number>3</span>))  <span class=comment># 返回 [('a','b','c'), ('1','2','3')]</span></span><br></pre></table></figure><p>参数解压也可以和其他函数共同使用:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">add</span>(<span class=params>a, b</span>): <span class=keyword>return</span> a + b</span><br><span class=line></span><br><span class=line>add(<span class=number>1</span>, <span class=number>2</span>)           <span class=comment># 返回 3</span></span><br><span class=line>add([<span class=number>1</span>, <span class=number>2</span>])         <span class=comment># 报错</span></span><br><span class=line>add(*[<span class=number>1</span>, <span class=number>2</span>])        <span class=comment># 返回 3</span></span><br></pre></table></figure><p>虽然不太实用，不过是个不错的让代码变得简洁的技巧。<h3 id=不定长参数传递-args-and-kwargs><a title="不定长参数传递 args and kwargs" class=headerlink href=#不定长参数传递-args-and-kwargs></a>不定长参数传递 args and kwargs</h3><p>假设我们要创建一个高阶函数，该函数输入一个旧函数，并返回一个新的函数，新函数是旧函数乘以 2 :<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">doubler</span>(<span class=params>f</span>):</span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">g</span>(<span class=params>x</span>):</span><br><span class=line>      <span class=keyword>return</span> <span class=number>2</span> * f(x)</span><br><span class=line>    <span class=keyword>return</span> g</span><br></pre></table></figure><p>运行例子:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">f1</span>(<span class=params>x</span>):</span><br><span class=line>    <span class=keyword>return</span> x + <span class=number>1</span></span><br><span class=line></span><br><span class=line>g = doubler(f1)</span><br><span class=line><span class=built_in>print</span> g(<span class=number>3</span>)        <span class=comment># 8 (== ( 3 + 1) * 2)</span></span><br><span class=line><span class=built_in>print</span> g(-<span class=number>1</span>)       <span class=comment># 0 (== (-1 + 1) * 2)</span></span><br></pre></table></figure><p>然而只要传递的参数大于一个，该方法就不太好用了:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">f2</span>(<span class=params>x, y</span>):</span><br><span class=line>    <span class=keyword>return</span> x + y</span><br><span class=line></span><br><span class=line>g = doubler(f2)</span><br><span class=line><span class=built_in>print</span> g(<span class=number>1</span>, <span class=number>2</span>) <span class=comment># 报错 TypeError: g() takes exactly 1 argument (2 given)</span></span><br></pre></table></figure><p>所以我们需要指定一个函数，使得它能够容纳任意数量的参数，然后利用参数解压缩实现传递多个参数，这看起来有那么一点神奇:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">magic</span>(<span class=params>*args, **kwargs</span>):</span><br><span class=line>    <span class=built_in>print</span> <span class=string>"unnamed args:"</span>, args</span><br><span class=line>    <span class=built_in>print</span> <span class=string>"keyword args:"</span>, kwargs</span><br><span class=line>magic(<span class=number>1</span>, <span class=number>2</span>, key=<span class=string>"word"</span>, key2=<span class=string>"word2"</span>)</span><br><span class=line><span class=comment># 输出结果：</span></span><br><span class=line><span class=comment># unnamed args: (1, 2)</span></span><br><span class=line><span class=comment># keyword args: {'key2': 'word2', 'key': 'word'}</span></span><br></pre></table></figure><p>当我们像这样定义一个函数时，<code>args</code> (arguments 的缩写)是一个包含未命名参数的元组，而 <code>kwargs</code> (keyword arguments 的缩写)是包含命名参数的字典。<p>它们也可以用在传递的参数为列表（或元组）或数组的情况：<br>n:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">other_way_magic</span>(<span class=params>x, y, z</span>):</span><br><span class=line>    <span class=keyword>return</span> x + y + z</span><br><span class=line></span><br><span class=line>x_y_list = [<span class=number>1</span>, <span class=number>2</span>]</span><br><span class=line>z_dict = { <span class=string>"z"</span> : <span class=number>3</span> }</span><br><span class=line><span class=built_in>print</span> other_way_magic(*x_y_list, **z_dict)    <span class=comment># 6</span></span><br></pre></table></figure><p>你可以用它配合各种奇怪的方法使用，但我们只用它来解决高阶函数传递不定长参数的问题:<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">doubler_correct</span>(<span class=params>f</span>):</span><br><span class=line>    <span class=string>"""不论 f 是什么都能有效运行"""</span></span><br><span class=line>    <span class=keyword>def</span> <span class="title function_">g</span>(<span class=params>*args, **kwargs</span>):</span><br><span class=line>        <span class=string>"""不论有多少参数，该函数都能正确将参数传递给 f"""</span></span><br><span class=line>        <span class=keyword>return</span> <span class=number>2</span> * f(*args, **kwargs)</span><br><span class=line>    <span class=keyword>return</span> g</span><br><span class=line></span><br><span class=line>g = doubler_correct(f2)</span><br><span class=line><span class=built_in>print</span> g(<span class=number>1</span>, <span class=number>2</span>) <span class=comment># 6</span></span><br></pre></table></figure><h3 id=欢迎来到数据科学的世界！><a class=headerlink href=#欢迎来到数据科学的世界！ title=欢迎来到数据科学的世界！></a>欢迎来到数据科学的世界！</h3><p>叮！恭喜你又打开了新世界的大门！接下来就可以去愉快地玩耍啦~<p><strong>相关阅读:</strong><p><a href=https://philoli.com/python-tutorails-basic-level rel=noopener target=_blank>数据科学中常用的 Python 语法(基础)</a></div><div><ul class=post-copyright><li class=post-copyright-author><strong>Post author: </strong>Philo Li<li class=post-copyright-link><strong>Post link: </strong> <a title="数据科学中 Python 的常用语法(进阶)" href=https://philo-li.com/python-tutorails-advanced-level/>https://philo-li.com/python-tutorails-advanced-level/</a><li class=post-copyright-license><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/Python/ rel=tag># Python</a></div><div class=post-nav><div class=post-nav-item><a title="数据科学中 Python 的常用语法(基础)" href=/python-tutorails-basic-level/ rel=prev> <i class="fa fa-chevron-left"></i> 数据科学中 Python 的常用语法(基础) </a></div><div class=post-nav-item><a title="Hello 2019" href=/hello2019/ rel=next> Hello 2019 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>Table of Contents<li class=sidebar-nav-overview>Overview</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%92%E5%BA%8F-Sorting><span class=nav-number>1.</span> <span class=nav-text>排序 Sorting</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90-List-Comprehensions><span class=nav-number>2.</span> <span class=nav-text>列表解析 List Comprehensions</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8-Generators-and-Iterators><span class=nav-number>3.</span> <span class=nav-text>生成器和迭代器 Generators and Iterators</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%8F%E6%9C%BA-Randomness><span class=nav-number>4.</span> <span class=nav-text>随机 Randomness</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-Regular-Expressions><span class=nav-number>5.</span> <span class=nav-text>正则表达式 Regular Expressions</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-Object-Oriented-Programming><span class=nav-number>6.</span> <span class=nav-text>面向对象编程 Object-Oriented Programming</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%87%BD%E6%95%B0%E5%B7%A5%E5%85%B7-Functional-Tools><span class=nav-number>7.</span> <span class=nav-text>函数工具 Functional Tools</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0-partial><span class=nav-number>7.1.</span> <span class=nav-text>部分函数 partial</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%98%A0%E5%B0%84-map><span class=nav-number>7.2.</span> <span class=nav-text>映射 map</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BF%87%E6%BB%A4%E5%99%A8-filter><span class=nav-number>7.3.</span> <span class=nav-text>过滤器 filter</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%A9%E5%87%8F-reduce><span class=nav-number>7.4.</span> <span class=nav-text>缩减 reduce</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9E%9A%E4%B8%BE-enumerate><span class=nav-number>8.</span> <span class=nav-text>枚举 enumerate</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E5%8E%8B-zip-and-Argument-Unpacking><span class=nav-number>9.</span> <span class=nav-text>压缩和参数解压 zip and Argument Unpacking</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8E%8B%E7%BC%A9-zip><span class=nav-number>9.1.</span> <span class=nav-text>压缩 zip</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0%E8%A7%A3%E5%8E%8B-Argument-Unpacking><span class=nav-number>9.2.</span> <span class=nav-text>参数解压 Argument Unpacking</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-args-and-kwargs><span class=nav-number>10.</span> <span class=nav-text>不定长参数传递 args and kwargs</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%81><span class=nav-number>11.</span> <span class=nav-text>欢迎来到数据科学的世界！</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt="Philo Li" class=site-author-image itemprop=image src=/uploads/avatar.jpg><p class=site-author-name itemprop=name>Philo Li<div class=site-description itemprop=description>Do something cool</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>11</span> <span class=site-state-item-name>posts</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>4</span> <span class=site-state-item-name>categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>4</span> <span class=site-state-item-name>tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="GitHub → https://github.com/philo-li" href=https://github.com/philo-li rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:philo.li.official@gmail.com" href=mailto:philo.li.official@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="Twitter → https://x.com/philo2022" href=https://x.com/philo2022 rel=noopener target=_blank><i class="fab fa-twitter fa-fw"></i>Twitter</a> </span><span class=links-of-author-item> <a title="YouTube → https://youtube.com/yourname" href=https://youtube.com/yourname rel=noopener target=_blank><i class="fab fa-youtube fa-fw"></i>YouTube</a> </span><span class=links-of-author-item> <a title="Instagram → https://instagram.com/yourname" href=https://instagram.com/yourname rel=noopener target=_blank><i class="fab fa-instagram fa-fw"></i>Instagram</a> </span></div><div class="cc-license motion-element" itemprop=license><a class=cc-opacity href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><img alt="Creative Commons" src=/images/cc-by-nc-sa.svg></a></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> Links</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://philoli.com/ rel=noopener target=_blank title=https://philoli.com>Title</a></ul></div></div></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Philo Li</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title="Symbols count total">31k</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title="Reading time total">1:53</span></div><div class=powered-by>Powered by <a class=theme-link href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a class=theme-link href=https://mist.theme-next.org/ rel=noopener target=_blank>NexT.Mist</a></div></div></footer></div><script src=/lib/anime.min.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script>